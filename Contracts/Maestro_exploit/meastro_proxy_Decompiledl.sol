//https://etherscan.io/address/0x80a64c6D7f12C47B7c66c5B4E20E72bc1FCd5d9e#code

// Decompiled by library.dedaub.com
// 2023.10.20 19:00 UTC
// Compiled using the solidity compiler version 0.8.21


// Data structures and variables inferred from the use of storage instructions
uint256 ___function_selector__; // STORAGE[0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc] bytes 0 to 19


// Events
Upgraded(address);

function 0xea(uint256 varg0) private { 
    require(varg0 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)
    return 32 + (~0x1f & 31 + varg0);
}

// Note: The function selector is not present in the original solidity code.
// However, we display it for the sake of completeness.

function __function_selector__(bytes4 function_selector, uint256 varg1, uint256 varg2) public payable { 
    if (address(0xe8ac39f0a15dc7eb9cf32c7639e633f24f9ec9ab) - msg.sender) {
        CALLDATACOPY(0, 0, msg.data.length);
        v0 = ___function_selector__.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);
        require(v0, 0, RETURNDATASIZE()); // checks call status, propagates error data on error
        return MEM[0 len (RETURNDATASIZE())];
    } else {
        require(0x4f1ef28600000000000000000000000000000000000000000000000000000000 == function_selector, ProxyDeniedAdminAccess());
        require(4 <= msg.data.length);
        require(~3 + msg.data.length >= 64);
        require(!(varg1 - address(varg1)));
        require(varg2 <= uint64.max);
        require(varg2 + 35 < msg.data.length);
        v1 = 0xea(varg2.length);
        v2 = new bytes[](varg2.length);
        require(!((v2 + (~0x1f & 31 + v1) < v2) | (v2 + (~0x1f & 31 + v1) > uint64.max)), Panic(65)); // failed memory allocation (too much memory)
        require(varg2 + varg2.length + 36 <= msg.data.length);
        CALLDATACOPY(v2.data, varg2.data, varg2.length);
        v2[varg2.length] = 0;
        require((address(varg1)).code.size, ERC1967InvalidImplementation(address(varg1)));
        ___function_selector__ = address(varg1);
        emit Upgraded(address(varg1));
        if (!v2.length) {
            require(!msg.value, ERC1967NonPayable());
        } else {
            v3, /* uint256 */ v4 = address(varg1).delegatecall(MEM[(v2.data) len (v2.length)], MEM[0 len 0]).gas(msg.gas);
            if (!RETURNDATASIZE()) {
                v5 = v6 = 96;
            } else {
                v7 = 0xea(RETURNDATASIZE());
                v5 = MEM[64];
                require(!((v5 + (~0x1f & 31 + v7) < v5) | (v5 + (~0x1f & 31 + v7) > uint64.max)), Panic(65)); // failed memory allocation (too much memory)
                MEM[64] = v5 + (~0x1f & 31 + v7);
                MEM[v5] = RETURNDATASIZE();
                RETURNDATACOPY(v4, 0, RETURNDATASIZE());
            }
            if (v3) {
                v8 = v9 = !MEM[v5];
                if (v9) {
                    v8 = v10 = !(address(varg1)).code.size;
                    // Unknown jump to Block 0x2b4B0x204B0x175B0x60. Refer to 3-address code (TAC);
                }
                require(!v8, AddressEmptyCode(address(varg1)));
                // Unknown jump to Block 0x18dB0x60. Refer to 3-address code (TAC);
            } else {
                require(!MEM[v5], 32 + v5, MEM[v5]);
                revert(FailedInnerCall());
            }
        }
        exit;
    }
}
