//https://library.dedaub.com/ethereum/address/0x8eae9827b45bcc6570c4e82b9e4fe76692b2ff7a/decompiled

// Decompiled by library.dedaub.com
// 2023.10.23 00:47 UTC
// Compiled using the solidity compiler version 0.8.21


// Data structures and variables inferred from the use of storage instructions
uint256 _sEAPORT; // STORAGE[0x4]
uint256 _lOOKS_RARE; // STORAGE[0xb]
uint256 stor_10; // STORAGE[0x10]
uint256 stor_12; // STORAGE[0x12]
uint256 owner_13; // STORAGE[0x13]
uint256 stor_14; // STORAGE[0x14]
uint256 _uniswapV3SwapCallback; // STORAGE[0x15]
uint256 stor_16; // STORAGE[0x16]
uint256 _execute; // STORAGE[0x18]
uint256 _factory; // STORAGE[0x0] bytes 0 to 19
uint256 _wETH; // STORAGE[0x1] bytes 0 to 19
uint256 _wETH9; // STORAGE[0x2] bytes 0 to 19
uint256 _pERMIT2; // STORAGE[0x3] bytes 0 to 19
uint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19
uint256 _x2Y2; // STORAGE[0x6] bytes 0 to 19
uint256 _fOUNDATION; // STORAGE[0x7] bytes 0 to 19
uint256 _sUDOSWAP; // STORAGE[0x8] bytes 0 to 19
uint256 stor_9_0_19; // STORAGE[0x9] bytes 0 to 19
uint256 _cRYPTOPUNKS; // STORAGE[0xa] bytes 0 to 19
uint256 stor_c_0_19; // STORAGE[0xc] bytes 0 to 19
uint256 _collectRewards; // STORAGE[0xd] bytes 0 to 19
uint256 stor_e_0_19; // STORAGE[0xe] bytes 0 to 19
uint256 _uNISWAP_V2_FACTORY; // STORAGE[0xf] bytes 0 to 19
uint256 _uNISWAP_V3_FACTORY; // STORAGE[0x11] bytes 0 to 19
uint256 stor_17_0_19; // STORAGE[0x17] bytes 0 to 19
uint256 stor_f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00_0_7; // STORAGE[0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00] bytes 0 to 7
uint256 _initialize; // STORAGE[0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00] bytes 8 to 8
uint256 _owner; // STORAGE[0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300] bytes 0 to 19


// Events
RewardsSent(uint256);
OwnershipTransferred(address, address);
Initialized(uint64);

function 0x2166(uint256 varg0) private { 
    require(varg0 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)
    return 32 + (~0x1f & 31 + varg0);
}

function 0x2221(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { 
    if (this - address(varg1)) {
        require(varg3 <= uint160.max, UnsafeCast());
        0x230c(varg0, varg1, varg2, address(varg3));
    } else {
        0x2282(varg0, varg2, varg3);
    }
    return ;
}

function 0x2282(address varg0, uint256 varg1, uint256 varg2) private { 
    if (varg0) {
        if (varg2 == int256.min) {
            v0, /* uint256 */ varg2 = varg0.balanceOf(this).gas(msg.gas);
            require(v0, MEM[64], RETURNDATASIZE());
            varg2 = v1 = 0;
            if (v0) {
                v2 = v3 = 32;
                if (v3 > RETURNDATASIZE()) {
                    v2 = RETURNDATASIZE();
                    0x7b7(MEM[64], v2);
                } else {
                    0x7b7(MEM[64], v3);
                }
                require(MEM[64] + v2 - MEM[64] >= 32);
            }
        }
        v4 = varg0.transfer(varg1, varg2).gas(msg.gas);
        require(((MEM[0] == 1) & (RETURNDATASIZE() > 31) | !RETURNDATASIZE()) & v4, Error('TRANSFER_FAILED'));
        // Unknown jump to Block 0x22400x2282. Refer to 3-address code (TAC);
    } else {
        v5 = varg1.call().value(varg2).gas(msg.gas);
        require(v5, Error('ETH_TRANSFER_FAILED'));
    }
    return ;
}

function 0x230c(address varg0, address varg1, address varg2, address varg3) private { 
    require(_pERMIT2.code.size);
    v0 = _pERMIT2.transferFrom(varg1, varg2, varg3, varg0).gas(msg.gas);
    require(v0, MEM[64], RETURNDATASIZE());
    if (v0) {
        0x733(MEM[64]);
        return ;
    } else {
        return ;
    }
}

function 0x2373(uint256 varg0) private { 
    require(varg0 <= varg0 + 1, Panic(17)); // arithmetic overflow or underflow
    return varg0 + 1;
}

function 0x2381(uint256 varg0) private { 
    require(varg0 <= varg0 + 2, Panic(17)); // arithmetic overflow or underflow
    return varg0 + 2;
}

function 0x23ec(uint256 varg0) private { 
    require(varg0 + ~0 <= varg0, Panic(17)); // arithmetic overflow or underflow
    return varg0 + ~0;
}

function 0x23fa(uint256 varg0) private { 
    require(varg0 + ~1 <= varg0, Panic(17)); // arithmetic overflow or underflow
    return varg0 + ~1;
}

function _SafeSub(uint256 varg0, uint256 varg1) private { 
    require(varg0 - varg1 <= varg0, Panic(17)); // arithmetic overflow or underflow
    return varg0 - varg1;
}

function uniswapV3SwapCallback(int256 varg0, int256 varg1, bytes varg2) public nonPayable { 
    require(~3 + msg.data.length >= 96);
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    require(msg.data[4 + varg2] <= uint64.max);
    v0 = varg2.word0;
    require(v0.data <= msg.data.length);
    v1 = v2 = varg0 <= 0;
    if (v2) {
        v1 = v3 = varg1 <= 0;
        // Unknown jump to Block 0x1e0a. Refer to 3-address code (TAC);
    }
    require(!v1, V3InvalidSwap());
    require(4 + varg2 + 32 + msg.data[4 + varg2] - (4 + varg2 + 32) >= 64);
    require(varg2.word1 <= uint64.max);
    require(4 + varg2 + 32 + varg2.word1 + 31 < 4 + varg2 + 32 + msg.data[4 + varg2]);
    v4 = 0x2166(msg.data[4 + varg2 + 32 + varg2.word1]);
    0x7b7(MEM[64], v4);
    require(4 + varg2 + 32 + varg2.word1 + 32 + msg.data[4 + varg2 + 32 + varg2.word1] <= 4 + varg2 + 32 + msg.data[4 + varg2]);
    CALLDATACOPY(MEM[64] + 32, 4 + varg2 + 32 + varg2.word1 + 32, msg.data[4 + varg2 + 32 + varg2.word1]);
    MEM[MEM[64] + msg.data[4 + varg2 + 32 + varg2.word1] + 32] = 0;
    require(!(address(varg2.word2) - varg2.word2));
    require(20 <= msg.data[4 + varg2 + 32 + varg2.word1], ToAddressOutOfBounds());
    require(msg.data[4 + varg2 + 32 + varg2.word1] >= 23, ToUint24OutOfBounds());
    require(msg.data[4 + varg2 + 32 + varg2.word1] >= 43, ToAddressOutOfBounds());
    v5 = v6 = MEM[43 + MEM[64]];
    if (address(v5) > address(v6)) {
        // Unknown jump to Block 0x27660x2750B0x1e33. Refer to 3-address code (TAC);
    }
    0x74b(MEM[64]);
    MEM[v7.data] = ~uint248.max;
    MEM[MEM[64] + 33] = _uNISWAP_V3_FACTORY;
    MEM[MEM[64] + 53] = keccak256(address(v5), address(v5), uint24(msg.data[4 + varg2 + 32 + varg2.word1]));
    MEM[MEM[64] + 85] = stor_12;
    v8 = 0x268d(MEM[64] + 117, MEM[64], 10212);
    require(!(address(keccak256(MEM[(v7.data) len (v8.length)])) - msg.sender), V3InvalidCaller());
    if (varg0 <= 0) {
        v9 = v10 = address(v6) < address(v5);
        // Unknown jump to Block 0x1e55. Refer to 3-address code (TAC);
    } else {
        v9 = v11 = address(v5) < address(v6);
    }
    if (!v9) {
        if (0 == msg.data[4 + varg2 + 32 + varg2.word1] >= 66) {
            require(v12 <= _uniswapV3SwapCallback, V3TooMuchRequested());
            0x2221(v6, address(varg2.word2), msg.sender, v12);
        } else {
            if (msg.data[4 + varg2 + 32 + varg2.word1] + ~22 <= msg.data[4 + varg2 + 32 + varg2.word1]) {
                require(msg.data[4 + varg2 + 32 + varg2.word1] + 8 >= msg.data[4 + varg2 + 32 + varg2.word1] + ~22, SliceOverflow());
                require(msg.data[4 + varg2 + 32 + varg2.word1] >= 23, SliceOverflow());
                require(msg.data[4 + varg2 + 32 + varg2.word1] >= msg.data[4 + varg2 + 32 + varg2.word1], SliceOutOfBounds());
                require(msg.data[4 + varg2 + 32 + varg2.word1] != 23, NoSlice());
                v13 = v14 = MEM[64] + ((!(msg.data[4 + varg2 + 32 + varg2.word1] + ~22 & 0x1f) << 5) + (msg.data[4 + varg2 + 32 + varg2.word1] + ~22 & 0x1f));
                v15 = v16 = v14 + 23;
                while (v13 >= v14 + msg.data[4 + varg2 + 32 + varg2.word1] + ~22) {
                    MEM[v13] = MEM[v15];
                    v15 += 32;
                    v13 += 32;
                }
                require(v12 < int256.min);
                if (v12 != int256.min) {
                    require(20 <= msg.data[4 + varg2 + 32 + varg2.word1] + ~22, ToAddressOutOfBounds());
                    require(msg.data[4 + varg2 + 32 + varg2.word1] + ~22 >= 23, ToUint24OutOfBounds());
                    require(msg.data[4 + varg2 + 32 + varg2.word1] + ~22 >= 43, ToAddressOutOfBounds());
                    v17 = v18 = MEM[43 + MEM[64]];
                    if (address(v17) > address(v18)) {
                        // Unknown jump to Block 0x27660x2750B0x263d0x249. Refer to 3-address code (TAC);
                    }
                    0x74b(MEM[64]);
                    MEM[v19.data] = ~uint248.max;
                    MEM[MEM[64] + 33] = _uNISWAP_V3_FACTORY;
                    MEM[MEM[64] + 53] = keccak256(address(v17), address(v17), uint24(msg.data[4 + varg2 + 32 + varg2.word1] + ~22));
                    MEM[MEM[64] + 85] = stor_12;
                    v20 = 0x268d(MEM[64] + 117, MEM[64], 10212);
                    if (9911 == msg.sender) {
                        require(~0 + stor_17_0_19 <= uint160.max, Panic(17)); // arithmetic overflow or underflow
                    } else {
                        require(1 + address(stor_16) <= uint160.max, Panic(17)); // arithmetic overflow or underflow
                    }
                    MEM[MEM[address(varg2.word2)] + 32] = 64;
                }
            }
            revert(Panic(17));
        }
    } else {
        0x2221(v5, address(varg2.word2), msg.sender, v12);
    }
    return ;
}

function 0xf9da581d() public payable { 
    v0 = v1 = 0;
    require(msg.data.length + ~3 >= v1, v1, v1);
    require(!(msg.sender - _owner), OwnableUnauthorizedAccount(msg.sender));
    if (!msg.value) {
        v0 = v2 = 2300;
        // Unknown jump to Block 0x1daa. Refer to 3-address code (TAC);
    }
    v3 = block.coinbase.call().value(msg.value).gas(v0);
    require(v3, MEM[64], RETURNDATASIZE());
    return MEM[v1 len v1];
}

function UNISWAP_V3_FACTORY() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _uNISWAP_V3_FACTORY;
}

function SUDOSWAP() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _sUDOSWAP;
}

function transferOwnership(address varg0) public nonPayable { 
    require(~3 + msg.data.length >= 32);
    require(!(varg0 - varg0));
    require(!(msg.sender - _owner), OwnableUnauthorizedAccount(msg.sender));
    require(varg0, OwnableInvalidOwner(0));
    _owner = varg0;
    emit OwnershipTransferred(_owner, varg0);
}

function onERC1155Received(address varg0, address varg1, uint256 varg2) public nonPayable { 
    require(~3 + msg.data.length >= 160);
    require(!(varg0 - varg0));
    require(!(varg1 - varg1));
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    require(varg2.length <= uint64.max);
    v0 = varg2.data;
    require(4 + varg2 + varg2.length + 32 <= msg.data.length);
    return 0xf23a6e6100000000000000000000000000000000000000000000000000000000;
}

function initialize(uint64 varg0) public nonPayable { 
    require(~3 + msg.data.length >= 32);
    require(!(varg0 - varg0));
    v0 = v1 = _initialize;
    if (!v1) {
        v0 = v2 = stor_f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00_0_7 >= varg0;
        // Unknown jump to Block 0x1beb. Refer to 3-address code (TAC);
    }
    require(!v0, InvalidInitialization());
    stor_f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00_0_7 = varg0;
    _initialize = 1;
    require(!(msg.sender - 0xbdeb498e872e36f899f237fd1b93673ed6c14474), Error('Not Owner'));
    require(_initialize, NotInitializing());
    require(_initialize, NotInitializing());
    require(msg.sender, OwnableInvalidOwner(0));
    _owner = msg.sender;
    emit OwnershipTransferred(_owner, msg.sender);
    require(_initialize, NotInitializing());
    _factory = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f;
    _wETH = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;
    require(_initialize, NotInitializing());
    v3 = MEM[64];
    require(!((v3 + 544 > uint64.max) | (v3 + 544 < v3)), Panic(65)); // failed memory allocation (too much memory)
    MEM[v3] = 0;
    MEM[v3 + 32] = 0;
    MEM[v3 + 64] = 0;
    MEM[v3 + 96] = 0;
    MEM[v3 + 128] = 0;
    MEM[v3 + 160] = 0;
    MEM[v3 + 192] = 0;
    MEM[v3 + 224] = 0;
    MEM[v3 + 256] = 0;
    MEM[v3 + 288] = 0;
    MEM[v3 + 320] = 0;
    MEM[v3 + 352] = 0;
    MEM[v3 + 384] = 0;
    MEM[v3 + 416] = 0;
    MEM[v3 + 448] = 0;
    MEM[v3 + 480] = 0;
    MEM[v3 + 512] = 0;
    MEM[v3 + 480] = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f;
    MEM[v3 + 512] = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;
    _pERMIT2 = 0x22d473030f116ddee9f6b43ac78ba3;
    _wETH9 = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;
    _sEAPORT = address(0xadc04c56bf30ac9d3c0aaf14dc) | bytes12(_sEAPORT);
    stor_5_0_19 = 0x941a6d105802cccaa06de58a13a6f49ebdcd481c;
    _x2Y2 = 0x74312363e45dcaba76c59ec49a7aa8a65a67eed3;
    _fOUNDATION = 0xcda72070e455bb31c7690a170224ce43623d0b6f;
    _sUDOSWAP = 0x2b2e8cda09bba9660dca5cb6233787738ad68329;
    stor_9_0_19 = 0xa42f6cada809bcf417deefbdd69c5c5a909249c0;
    _cRYPTOPUNKS = 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb;
    _lOOKS_RARE = address(0xe655fae4d56241588680f86e3b2377) | bytes12(_lOOKS_RARE);
    stor_c_0_19 = 0xf4d2888d29d722226fafa5d9b24f9164c092421e;
    _collectRewards = 0x554f068365ed43dcc98dcd7fd7a8208a5638c72;
    stor_e_0_19 = 0xea37093ce161f090e443f304e1bf3a8f14d7bb40;
    _uNISWAP_V2_FACTORY = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f;
    stor_10 = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f;
    _uNISWAP_V3_FACTORY = 0x1f98431c8ad98523631ae4a59f267346ea31f984;
    stor_12 = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;
    require(_initialize, NotInitializing());
    owner_13 = 10000;
    require(_initialize, NotInitializing());
    stor_14 = ~0;
    _uniswapV3SwapCallback = ~0;
    stor_16 = bytes12(stor_16) | 0x1000276a3;
    stor_17_0_19 = 0xfffd8963efd1fc6a506488495d951d5263988d26;
    require(_initialize, NotInitializing());
    _execute = 1;
    _initialize = 0;
    emit Initialized(varg0);
}

function 0x268d(uint256 varg0, uint256 varg1, uint256 varg2) private { 
    require(!((v0 + (varg0 - varg1 + 31 & ~0x1f) > uint64.max) | (v0 + (varg0 - varg1 + 31 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)
    return v0;
}

function 0xe81dc5c1(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public payable { 
    require(~3 + msg.data.length >= 160);
    require(varg0 <= uint64.max);
    require(4 + varg0 + 31 < msg.data.length);
    v0 = v1 = varg0.length;
    require(v1 <= uint64.max);
    v0 = v2 = varg0.data;
    require((v1 << 5) + (4 + varg0) + 32 <= msg.data.length);
    require(!(bool(varg2) - varg2));
    require(!bool(msg.value < varg1), Error("Tip can't be bigger than tx value"));
    v0 = v3 = msg.value - varg1;
    if (v3 <= msg.value) {
        v0 = v4 = _factory;
        v5 = 0x7f8(v1);
        v0 = v6 = MEM[64];
        0x7b7(v6, v5);
        v7 = v8 = v6 + 32;
        require(v2 + (v1 << 5) <= msg.data.length);
        while (v0 >= v2 + (v1 << 5)) {
            require(!(address(msg.data[v0]) - msg.data[v0]));
            MEM[v7] = msg.data[v0];
            v7 = v7 + 32;
            v0 = v0 + 32;
        }
        require(!bool(v1 < 2), Error('UniswapV2Library: INVALID_PATH'));
        v9 = 0x7f8(v1);
        v0 = v10 = MEM[64];
        0x7b7(v10, v9);
        v11 = 0x7f8(v1);
        CALLDATACOPY(v10 + 32, msg.data.length, v11 + ~31);
        v12 = v13 = 6853;
        v14 = v15 = 0x23ec(v1);
        while (1) {
            v16 = 0x3cba(v0, v14);
            MEM[v16] = v0;
            v0 = v17 = 0x23ec(MEM[v0]);
            while (!v0) {
                v0 = v18 = 7010;
                v0 = v19 = 6970;
                v20 = v21 = 6951;
                v0 = v22 = 7034;
                v23 = 0x23ec(v0);
                v24 = v25 = 0x3cba(v0, v23);
                while (1) {
                    v0 = v26 = address(MEM[v24]);
                    // Unknown jump to Block {'0x1b27', '0x1b34'}. Refer to 3-address code (TAC);
                    v20 = v27 = 6964;
                    v24 = v28 = 0x3cba(v0, v0);
                }
                v29, v30 = 0x4c34(v0, v26);
                v31 = 0x4b93(v0, v0, v26);
                v32, /* uint112 */ v33, /* uint112 */ v34, /* uint32 */ v35 = address(v31).getReserves().gas(msg.gas);
                require(v32, MEM[64], RETURNDATASIZE());
                if (v32) {
                    v36 = v37 = 96;
                    if (v37 > RETURNDATASIZE()) {
                        v36 = RETURNDATASIZE();
                        0x7b7(MEM[64], v36);
                    } else {
                        0x7b7(MEM[64], v37);
                    }
                    require(MEM[64] + v36 - MEM[64] >= 96);
                    require(!0x902f1ac00000000000000000000000000000000000000000000000000000000);
                    require(!(v34 - uint112(v34)));
                    require(!(v35 - uint32(v35)));
                    v38 = uint112(v33);
                    v38 = v39 = uint112(v34);
                    if (0 != (address(v0) == address(v30))) {
                        // Unknown jump to Block 0x1b3a. Refer to 3-address code (TAC);
                    }
                } else {
                    v38 = v40 = uint112(0);
                    v38 = v41 = uint112(0);
                    if (0 != (address(v0) == address(v30))) {
                        // Unknown jump to Block 0x1b3a. Refer to 3-address code (TAC);
                    }
                }
                v42 = 0x23ec(MEM[v0]);
                v43 = v44 = v0 == v42;
                if (v44) {
                    v43 = v45 = v0 > v38;
                    // Unknown jump to Block 0x1b4d. Refer to 3-address code (TAC);
                }
                if (v43) {
                    v46 = 0x23ec(v38);
                    v47 = 0x3cba(v0, v0);
                    MEM[v47] = v46;
                    // Unknown jump to Block 0x1b52. Refer to 3-address code (TAC);
                }
                v48 = 0x3cba(v0, v0);
                require(MEM[v48], Error('UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'));
                if (v38) {
                    require(!bool(!v38), Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
                    // Unknown jump to Block 0x171a0x26c. Refer to 3-address code (TAC);
                } else {
                    require(!bool(!v38), Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
                }
                v49 = 0;
                v50 = !MEM[v48];
                if (bool(MEM[v48])) {
                    v49 = v51 = _SafeMul(v38, MEM[v48]);
                    v52 = _SafeDiv(v51, MEM[v48]);
                    v50 = v53 = v52 == v38;
                    // Unknown jump to Block 0x504d0x26c. Refer to 3-address code (TAC);
                }
                require(v50, Error('ds-math-mul-overflow'));
                if (!v49 | (1000 == v49 * 1000 / v49)) {
                    require(!(v49 * 1000 / 1000 - v49), Error('ds-math-mul-overflow'));
                    if (v38 - MEM[v48] <= v38) {
                        v54 = 0x4fc6(v38 - MEM[v48]);
                        v55 = _SafeDiv(v49 * 1000, v54);
                        if (v55 <= v55 + 1) {
                            require(v55 + 1 >= v55, Error('ds-math-add-overflow'));
                            v56 = 0x23ec(v0);
                            v57 = 0x3cba(v0, v56);
                            MEM[v57] = v55 + 1;
                            if (v0) {
                                v0 += ~0;
                            }
                        }
                    }
                }
            }
            v0 = v58 = 5729;
            v0 = v59 = 6919;
            v0 = v60 = 6905;
            v12 = v61 = 6898;
            v14 = v62 = 0x23ec(MEM[v0]);
        }
        v0 = v63 = MEM[v16];
        require(MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v64 = MEM[32 + v0] > v0;
        v65 = 0x7f8(v0);
        v0 = v66 = MEM[64];
        0x7b7(v66, v65);
        v67 = v68 = v66 + 32;
        require(v69 + (v0 << 5) <= msg.data.length);
        while (v0 >= v69 + (v0 << 5)) {
            require(!(address(msg.data[v0]) - msg.data[v0]));
            MEM[v67] = msg.data[v0];
            v67 = v67 + 32;
            v0 = v0 + 32;
        }
        if (0 == v64) {
            if (block.timestamp <= block.timestamp + 100) {
                v0 = v70 = 8768;
                v0 = v71 = 5723;
                v0 = v72 = msg.sender;
                require(!bool(block.timestamp > block.timestamp + 100), Error('UniswapV2Router: EXPIRED'));
                v73 = v74 = 21788;
                require(v0, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v75 = 32 + v66;
                while (1) {
                    v0 = v76 = address(MEM[v75]);
                    // Unknown jump to Block {'0x49e50x5db8B0x1b07', '0x551c0x5db8B0x1b07', '0x6450x5db8B0x1b07'}. Refer to 3-address code (TAC);
                    v73 = v77 = 1605;
                    require(1 < MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v75 = v78 = 64 + v0;
                    // Unknown jump to Block 0xa7d0x5db8B0x1b07. Refer to 3-address code (TAC);
                    v0 = v79, v0 = v80, v81 = 0x4942(_wETH, uint160.max, v76, 21814, v0, v0);
                    v0 = v82 = 0;
                    v0 = v83 = 0x5242(_factory, v0, v79);
                    require(MEM[v83], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    require(!bool(MEM[32 + v83] > v0), Error('UniswapV2Router: EXCESSIVE_INPUT_AMOUNT'));
                    require(MEM[v83], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    require(v81.code.size, v82, v82);
                    v84 = v81.deposit().value(MEM[32 + v83]).gas(msg.gas);
                    require(v84, MEM[64], RETURNDATASIZE());
                    v0 = v85 = 21968;
                    if (v84) {
                        0x733(MEM[64]);
                        0x3e6(MEM[64], MEM[64]);
                        // Unknown jump to Block 0x55970x5db8B0x1b07. Refer to 3-address code (TAC);
                    }
                    v0 = v86 = 32;
                    v0 = v87 = 21938;
                    v0 = v88 = 1467;
                    v0 = v89 = _wETH;
                    while (1) {
                        v0 = address(v0);
                        // Unknown jump to Block {'0x5bb0x5db8B0x1b07', '0x55b20x5db8B0x1b07'}. Refer to 3-address code (TAC);
                    }
                    v0 = v90 = 21958;
                    v0 = v91 = address(STORAGE[v0]);
                    v73 = v92 = 18917;
                    require(MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v75 = v93 = 32 + v0;
                    // Unknown jump to Block 0xa7d0x5db8B0x1b07. Refer to 3-address code (TAC);
                }
                v94, v95 = 0x4c34(v0, v76);
                MEM[MEM[64] + 32] = bytes20(v95 << 96);
            }
        } else if (block.timestamp <= block.timestamp + 100) {
            v0 = v96 = 5723;
            v0 = v97 = msg.sender;
            require(!bool(block.timestamp > block.timestamp + 100), Error('UniswapV2Router: EXPIRED'));
            v0 = v98 = 19068;
            require(v0, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v99 = v100 = 32 + v66;
            while (1) {
                v0 = v101 = address(MEM[v99]);
                // Unknown jump to Block {'0x6450x4a60B0x5dd2B0x1b07', '0x50a90x4a60B0x5dd2B0x1b07', '0x4a7cB0x5dd2B0x1b07', '0x49e50x4a60B0x5dd2B0x1b07', '0x50990x4a60B0x5dd2B0x1b07'}. Refer to 3-address code (TAC);
                v102, v103 = 0x4c34(v0, v0);
                v104 = new bytes[](40);
                v104[20] = bytes20(v102 << 96);
                require(!((v104 + 96 > uint64.max) | (v104 + 96 < v104)), Panic(65)); // failed memory allocation (too much memory)
                v105 = v104.length;
                v106 = bytes20(v0 << 96);
                0x74b(MEM[64]);
                v0 = v107 = address(keccak256(0xff, v106, keccak256(bytes20(v103 << 96), bytes20(v102 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f));
                // Unknown jump to Block {'0x49f10x4a60B0x5dd2B0x1b07', '0x511f0x4a60B0x5dd2B0x1b07', '0x5bb0x4a60B0x5dd2B0x1b07'}. Refer to 3-address code (TAC);
                require(MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v108 = v0.transfer(address(v107), MEM[32 + v0]).value(v0).gas(msg.gas);
                if (v108) {
                    v0 = v109 = 2178;
                    if (v108) {
                        v0 = v110 = 3252;
                        v111 = v112 = 32;
                        if (v112 > RETURNDATASIZE()) {
                            v111 = v113 = RETURNDATASIZE();
                            0x7b7(MEM[64], v113);
                        } else {
                            0x7b7(MEM[64], v112);
                        }
                        require(MEM[64] + v111 - MEM[64] >= 32);
                        require(!(bool(v114) - v114));
                        // Unknown jump to Block 0x8820x4a60B0x5dd2B0x1b07. Refer to 3-address code (TAC);
                    } else {
                        require(v0, Panic(1)); // low-level assert failed
                        v0 = 0;
                    }
                }
                while (1) {
                    v0 = address(v0);
                    // Unknown jump to Block {'0x49c90x4a60B0x5dd2B0x1b07', '0x5bb0x4a60B0x5dd2B0x1b07', '0x51310x4a60B0x5dd2B0x1b07'}. Refer to 3-address code (TAC);
                }
                v0 = v115 = 18929;
                v0 = v116 = address(STORAGE[v0]);
                v0 = v117 = 18917;
                require(MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v99 = v118 = 32 + v0;
                // Unknown jump to Block 0xa7d0x4a60B0x5dd2B0x1b07. Refer to 3-address code (TAC);
                v119 = 0x4053();
                require(v0.code.size);
                v120 = v121 = MEM[64];
                MEM[v121] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000;
                v122 = 0x4069(v121 + 4, v0, v0, v0, v119);
                v123 = v0.call(MEM[v121 len (v122 - v121)], MEM[v121 len 0]).gas(msg.gas);
                if (v123) {
                    v0 = v124 = 20862;
                    if (v123) {
                        v125 = v126 = 20880;
                        0x733(v121);
                    }
                }
                require(v0 != ~0, Panic(17)); // arithmetic overflow or underflow
                v0 += 1;
                v127 = 0x23ec(MEM[v0]);
                if (v0 < v127) {
                    v0 = v128 = 20633;
                    v99 = v129 = 0x3cba(v0, v0);
                }
                v0 = v130 = _factory;
                // Unknown jump to Block 0x4b930x4a60B0x5dd2B0x1b07. Refer to 3-address code (TAC);
                v0 = v131 = 1605;
                require(1 < MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v99 = 64 + v0;
                // Unknown jump to Block 0xa7d0x4a60B0x5dd2B0x1b07. Refer to 3-address code (TAC);
                v0 = v132 = 20649;
                v133 = 2685;
                v134 = 0x2373(v0);
                v99 = v135 = 0x3cba(v0, v134);
                v136 = MEM[v135] < v0;
                require(!bool(v136), Error('UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'));
                require(MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                require(v0.code.size, v0, v0);
                v120 = v137 = MEM[64];
                v138 = v0.deposit().value(MEM[32 + v0]).gas(msg.gas);
                if (v138) {
                    v0 = v139 = 18992;
                    if (v138) {
                        v125 = v140 = 19034;
                        0x733(v137);
                    }
                }
                v0 = v141 = 32;
                v0 = v142 = 18889;
                v0 = v143 = 1467;
                v0 = v144 = _wETH;
                // Unknown jump to Block 0x5bb0x4a60B0x5dd2B0x1b07. Refer to 3-address code (TAC);
                0x3e6(v120, v120);
                // Unknown jump to Block 0x49ae0x4a60B0x5dd2B0x1b07. Refer to 3-address code (TAC);
                // Unknown jump to Block 0x51780x4a60B0x5dd2B0x1b07. Refer to 3-address code (TAC);
                v145, v146 = 0x4c34(v0, v101);
                v147 = 0x2373(v0);
                v148 = 0x3cba(v0, v147);
                v0 = v149 = MEM[v148];
                if (address(v146) - address(v0)) {
                    v0 = v150 = 20785;
                    v0 = v151 = 1467;
                    v0 = v152 = 1467;
                    v0 = v153 = 0;
                    // Unknown jump to Block 0x50e90x4a60B0x5dd2B0x1b07. Refer to 3-address code (TAC);
                } else {
                    v0 = v154 = 20785;
                    v0 = v155 = 1467;
                    v0 = v156 = 1467;
                    v0 = v157 = 0;
                }
                v158 = 0x23fa(MEM[v0]);
                if (v0 >= v158) {
                    // Unknown jump to Block 0x51210x4a60B0x5dd2B0x1b07. Refer to 3-address code (TAC);
                } else {
                    v99 = v159, v0 = v160, v0 = v161, v0 = v162, v0 = v163, v0 = v164, v0 = v165, v0 = v166, v0 = v167, v0, v0 = v168, v0 = v169 = 0x5115(_factory, 2685, 1605, v101, v0, 20767, v101, v0, v0, v0, v0, v0);
                }
                v0 = v170 = _wETH;
                require(v170 == address(v101), Error('UniswapV2Router: INVALID_PATH'));
                v0 = v171 = 0;
                v0 = v172 = 19139;
                v0 = 0x4d79(_factory, v0, v0);
                v133 = v173 = 1554;
                v134 = v174 = 0x23ec(MEM[v0]);
            }
            0x5dfd(v175, 8768);
            // Unknown jump to Block 0x16610x26c. Refer to 3-address code (TAC);
            RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());
            revert(MEM[64], RETURNDATASIZE());
        }
        revert(Panic(17));
        v176 = 0;
        while (v176 >= MEM[96]) {
            MEM[64 + (v176 + MEM[64])] = MEM[v176 + 128];
            v176 += 32;
        }
        MEM[MEM[64] + MEM[96] + 64] = 0;
        return 32, MEM[96], bytes20(v94 << 96);
    }
    revert(Panic(17));
}

function getAmountsOut(uint256 varg0, address[] varg1) public nonPayable { 
    require(msg.data.length + ~3 >= 64);
    require(varg1 <= uint64.max);
    require(4 + varg1 + 31 < msg.data.length);
    v0 = v1 = varg1.data;
    v2 = 0x7f8(varg1.length);
    0x7b7(MEM[64], v2);
    MEM[MEM[64]] = varg1.length;
    v3 = v4 = MEM[64] + 32;
    require(v1 + (varg1.length << 5) <= msg.data.length);
    while (v0 >= v1 + (varg1.length << 5)) {
        require(!(address(msg.data[v0]) - msg.data[v0]));
        MEM[v3] = msg.data[v0];
        v3 = v3 + 32;
        v0 = v0 + 32;
    }
    v5 = 0x4d79(_factory, varg0, MEM[64]);
    v6 = 0x527(MEM[64], v5);
    return MEM[(MEM[64]) len (v6 - MEM[64])];
}

function 0xcc988feb() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return stor_9_0_19;
}

function 0xc62029ed() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return stor_5_0_19;
}

function factory() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _factory;
}

function 0x2810() private { 
    if (!RETURNDATASIZE()) {
        return 96;
    } else {
        v0 = 0x2166(RETURNDATASIZE());
        0x7b7(MEM[64], v0);
        MEM[MEM[64]] = RETURNDATASIZE();
        RETURNDATACOPY(MEM[64] + 32, 0, RETURNDATASIZE());
        return MEM[64];
    }
}

function onERC1155BatchReceived(address varg0, address varg1, uint256[] varg2, uint256[] varg3, bytes varg4) public nonPayable { 
    require(~3 + msg.data.length >= 160);
    require(!(varg0 - varg0));
    require(!(varg1 - varg1));
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    require(varg2.length <= uint64.max);
    v0 = varg2.data;
    require((varg2.length << 5) + (4 + varg2) + 32 <= msg.data.length);
    require(varg3 <= uint64.max);
    require(4 + varg3 + 31 < msg.data.length);
    require(varg3.length <= uint64.max);
    v1 = varg3.data;
    require((varg3.length << 5) + (4 + varg3) + 32 <= msg.data.length);
    require(varg4 <= uint64.max);
    require(4 + varg4 + 31 < msg.data.length);
    require(varg4.length <= uint64.max);
    v2 = varg4.data;
    require(4 + varg4 + varg4.length + 32 <= msg.data.length);
    return 0xbc197c8100000000000000000000000000000000000000000000000000000000;
}

function _SafeAdd(uint256 varg0, uint256 varg1, uint256 varg2) private { 
    require(varg2 < varg1, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    return varg0 + varg2;
}

function LOOKS_RARE() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return address(_lOOKS_RARE);
}

function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 varg0, address[] varg1, address varg2, uint256 varg3) public payable { 
    require(msg.data.length + ~3 >= 128);
    require(varg1 <= uint64.max);
    require(4 + varg1 + 31 < msg.data.length);
    v0 = v1 = varg1.data;
    v2 = 0x7f8(varg1.length);
    v3 = MEM[64];
    0x7b7(v3, v2);
    v4 = v5 = v3 + 32;
    require(v1 + (varg1.length << 5) <= msg.data.length);
    while (v0 >= v1 + (varg1.length << 5)) {
        require(!(address(msg.data[v0]) - msg.data[v0]));
        MEM[v4] = msg.data[v0];
        v4 = v4 + 32;
        v0 = v0 + 32;
    }
    require(!(varg2 - varg2));
    require(!bool(block.timestamp > varg3), Error('UniswapV2Router: EXPIRED'));
    v6 = v7 = 6161;
    require(varg1.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    v8 = 32 + v3;
    while (1) {
        v3 = v9 = address(MEM[v8]);
        // Unknown jump to Block {'0x5bb0x28f', '0x1811'}. Refer to 3-address code (TAC);
        while (1) {
            v3 = address(v3);
            // Unknown jump to Block {'0x5bb0x28f', '0x1876', '0xbe90x28f', '0xb820x28f'}. Refer to 3-address code (TAC);
        }
        v10 = MEM[64];
        v3 = v11 = 0x70a0823100000000000000000000000000000000000000000000000000000000;
        v12 = v3.balanceOf(address(v3)).gas(msg.gas);
        if (v12) {
            v3 = v13 = 3086;
            if (v12) {
                v14 = v15 = 3049;
                v16 = v17 = 1467;
                v3 = v18 = 2685;
                v19 = v20 = 3210;
                v3 = v21 = 1467;
                if (v3 <= RETURNDATASIZE()) {
                    0x7b7(v10, v3);
                }
            }
        }
        v3 = v22 = 1467;
        v6 = v23 = 1467;
        v3 = v24 = 3033;
        v3 = v25 = 3049;
        v3 = v26 = 0;
        while (1) {
            v27 = 0x23ec(MEM[v3]);
            if (v3 >= v27) {
                v28 = 0x23ec(MEM[v3]);
                v8 = v29 = 0x3cba(v3, v28);
            } else {
                v30 = v31 = 22100;
                v32 = v33 = 0x3cba(v3, v3);
                while (1) {
                    v3 = v34 = address(MEM[v32]);
                    // Unknown jump to Block {'0x6450x5631B0xbc10x28f', '0x566aB0xbc10x28f', '0x5654B0xbc10x28f'}. Refer to 3-address code (TAC);
                    v35, v36 = 0x4c34(v3, v34);
                    v37 = new bytes[](40);
                    v37[20] = bytes20(v35 << 96);
                    require(!((v37 + 96 > uint64.max) | (v37 + 96 < v37)), Panic(65)); // failed memory allocation (too much memory)
                    v38 = v37.length;
                    0x74b(MEM[64]);
                    v3 = v39 = address(keccak256(0xff, bytes20(v3 << 96), keccak256(bytes20(v36 << 96), bytes20(v35 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f));
                    // Unknown jump to Block {'0x5772B0xbc10x28f', '0x5bb0x5631B0xbc10x28f'}. Refer to 3-address code (TAC);
                    while (1) {
                        v3 = address(v3);
                        // Unknown jump to Block {'0x5692B0xbc10x28f', '0x5bb0x5631B0xbc10x28f'}. Refer to 3-address code (TAC);
                    }
                    v3 = v40 = 64;
                    v41 = v42 = 96;
                    v3 = v43 = 4;
                    v44, /* uint112 */ v45, /* uint112 */ v45, /* uint32 */ v46 = v3.getReserves().gas(msg.gas);
                    if (v44) {
                        v45 = v47 = 0;
                        if (v44) {
                            if (RETURNDATASIZE() < v42) {
                                v41 = v48 = RETURNDATASIZE();
                                0x7b7(MEM[v40], v48);
                            } else {
                                0x7b7(MEM[v40], v42);
                            }
                            require(MEM[v40] + v41 - MEM[v40] >= 96);
                            require(!0x902f1ac00000000000000000000000000000000000000000000000000000000);
                            require(!(v45 - uint112(v45)));
                            require(!(v46 - uint32(v46)));
                        }
                        v49 = v50 = uint112(v45);
                        v49 = v51 = uint112(v45);
                        if (address(v3) != address(v3)) {
                            // Unknown jump to Block 0x56ebB0xbc10x28f. Refer to 3-address code (TAC);
                        }
                        v52 = v53 = 32;
                        v54, v55 = address(v3).balanceOf(address(v3)).gas(msg.gas);
                        if (v54) {
                            v55 = v56 = 0;
                            if (v54) {
                                if (RETURNDATASIZE() < v53) {
                                    v52 = v57 = RETURNDATASIZE();
                                    // Unknown jump to Block 0xc450x5631B0xbc10x28f. Refer to 3-address code (TAC);
                                }
                                0x7b7(MEM[v40], v52);
                                require(MEM[v40] + v52 - MEM[v40] >= 32);
                            }
                            if (v55 - v49 <= v55) {
                                require(v55 - v49, Error('UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'));
                                v58 = v59 = bool(v49);
                                if (v59) {
                                    v58 = v60 = bool(v49);
                                    // Unknown jump to Block 0x4ef30x5631B0xbc10x28f. Refer to 3-address code (TAC);
                                }
                                require(v58, Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
                                if (!(v55 - v49) | (997 == (v55 - v49) * 997 / (v55 - v49))) {
                                    require(!((v55 - v49) * 997 / 997 - (v55 - v49)), Error('ds-math-mul-overflow'));
                                    v61 = 0;
                                    v62 = !v49;
                                    if (bool(v49)) {
                                        v61 = v63 = _SafeMul((v55 - v49) * 997, v49);
                                        v64 = _SafeDiv(v63, v49);
                                        v62 = v65 = v64 == (v55 - v49) * 997;
                                        // Unknown jump to Block 0x504d0x5631B0xbc10x28f. Refer to 3-address code (TAC);
                                    }
                                    require(v62, Error('ds-math-mul-overflow'));
                                    if (!v49 | (1000 == v49 * 1000 / v49)) {
                                        require(!(v49 * 1000 / 1000 - v49), Error('ds-math-mul-overflow'));
                                        if (v49 * 1000 <= v49 * 1000 + (v55 - v49) * 997) {
                                            require(v49 * 1000 + (v55 - v49) * 997 >= v49 * 1000, Error('ds-math-add-overflow'));
                                            v3 = v66 = _SafeDiv(v61, v49 * 1000 + (v55 - v49) * 997);
                                            if (address(v3) != address(v3)) {
                                                v3 = v67 = 0;
                                                // Unknown jump to Block 0x5748B0xbc10x28f. Refer to 3-address code (TAC);
                                            } else {
                                                v3 = v68 = 0;
                                            }
                                            v69 = 0x23fa(MEM[v3]);
                                            if (v3 < v69) {
                                                v3 = v70 = 22386;
                                                v30 = v71 = 1605;
                                                v72 = 0x2381(v3);
                                                v32 = v73 = 0x3cba(v3, v72);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());
                    revert(MEM[64], RETURNDATASIZE());
                    revert(Panic(17));
                    v74 = 0x4053();
                    require(v3.code.size);
                    MEM[MEM[v3]] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000;
                    v75 = 0x4069(MEM[v3] + v3, v3, v3, v3, v74);
                    v76 = v3.call(MEM[(MEM[v3]) len (v75 - MEM[v3])], MEM[(MEM[v3]) len 0]).gas(msg.gas);
                    if (v76) {
                        if (v76) {
                            0x733(MEM[v3]);
                            0x3e6(MEM[v3], MEM[v3]);
                            // Unknown jump to Block 0x3c8f0x5631B0xbc10x28f. Refer to 3-address code (TAC);
                        }
                        if (v3 != ~0) {
                            v3 += 1;
                        }
                    }
                    v30 = v77 = 22122;
                    v78 = 0x2373(v3);
                    v32 = v79 = 0x3cba(v3, v78);
                    v80, v3 = 0x4c34(v3, v34);
                    v3 = v81 = _factory;
                    v3 = v82 = 22162;
                    v3 = v83 = 1467;
                    v3 = v84 = 1467;
                    // Unknown jump to Block 0x4b930x5631B0xbc10x28f. Refer to 3-address code (TAC);
                }
            }
        }
        v3 = v85 = RETURNDATASIZE();
        0x7b7(v10, v3);
        require(v10 + v3 - v10 >= 32);
        v3 = v86 = MEM[v10];
        // Unknown jump to Block {'0xc8a0x28f', '0xc570x28f'}. Refer to 3-address code (TAC);
        // Unknown jump to Block 0xc270x28f. Refer to 3-address code (TAC);
        // Unknown jump to Block 0xbc10x28f. Refer to 3-address code (TAC);
        v10 = v87 = MEM[64];
        v88 = v3.balanceOf(address(v3)).gas(msg.gas);
        if (v88) {
            v14 = v89 = 3125;
            v16 = v90 = 3118;
            if (v88) {
                v19 = v91 = 3159;
                if (RETURNDATASIZE() < v3) {
                    // Unknown jump to Block 0xc5e0x28f. Refer to 3-address code (TAC);
                }
            }
        }
        v3 = v92 = 6282;
        v3 = v93 = address(STORAGE[v3]);
        v94 = v95 = 2826;
        require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v96 = v97 = 32 + v3;
        while (1) {
            v3 = v98 = address(MEM[v96]);
            // Unknown jump to Block {'0x6450xafeB0x1876', '0xb0a0xafeB0x1876'}. Refer to 3-address code (TAC);
            v94 = v99 = 1605;
            require(1 < MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v96 = 64 + v3;
            // Unknown jump to Block 0xa7d0xafeB0x1876. Refer to 3-address code (TAC);
        }
        v100, v101 = 0x4c34(v3, v98);
        v102 = new bytes[](40);
        v102[20] = bytes20(v100 << 96);
        require(!((v102 + 96 > uint64.max) | (v102 + 96 < v102)), Panic(65)); // failed memory allocation (too much memory)
        v103 = v102.length;
        0x74b(MEM[64]);
        v3 = v104 = 32;
        v105, v3 = v3.transfer(address(keccak256(0xff, bytes20(v3 << 96), keccak256(bytes20(v101 << 96), bytes20(v100 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)), msg.value).value(v3).gas(msg.gas);
        if (v105) {
            if (v105) {
                if (v104 > RETURNDATASIZE()) {
                    v3 = v106 = RETURNDATASIZE();
                    // Unknown jump to Block 0xca20x28f. Refer to 3-address code (TAC);
                }
                0x7b7(MEM[64], v3);
                require(MEM[64] + v3 - MEM[64] >= 32);
                require(!(bool(v3) - v3));
            }
            require(v3, Panic(1)); // low-level assert failed
            v3 = v107 = 2946;
            v3 = v108 = 1467;
            v6 = v109 = 1467;
            v110 = 0x23ec(MEM[v3]);
            v8 = v111 = 0x3cba(v3, v110);
        }
        require(_wETH == address(v9), Error('UniswapV2Router: INVALID_PATH'));
        require(_wETH.code.size);
        v3 = v112 = 0;
        v113 = _wETH.deposit().value(msg.value).gas(msg.gas);
        if (v113) {
            v3 = v114 = 2891;
            if (v113) {
                0x733(MEM[64]);
                0x3e6(MEM[64], MEM[64]);
                // Unknown jump to Block 0x185e. Refer to 3-address code (TAC);
            }
            v3 = v115 = 6262;
            v3 = v116 = 1467;
            v3 = v117 = _wETH;
        }
    }
    RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());
    revert(MEM[64], RETURNDATASIZE());
    v118 = v3 - v3;
    require(v118 <= v3, Panic(17)); // arithmetic overflow or underflow
    require(!bool(v118 < v3), Error('UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'));
    return MEM[v3 len v3];
}

function 0xb38248c7() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return stor_e_0_19;
}

function quote(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { 
    require(~3 + msg.data.length >= 96);
    require(varg0, Error('UniswapV2Library: INSUFFICIENT_AMOUNT'));
    v0 = v1 = bool(varg1);
    if (v1) {
        v0 = v2 = bool(varg2);
        // Unknown jump to Block 0x17110x299. Refer to 3-address code (TAC);
    }
    require(v0, Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
    v3 = 0;
    v4 = !varg2;
    if (bool(varg2)) {
        v3 = v5 = _SafeMul(varg0, varg2);
        v6 = _SafeDiv(v5, varg2);
        v4 = v7 = v6 == varg0;
        // Unknown jump to Block 0x504d0x299. Refer to 3-address code (TAC);
    }
    require(v4, Error('ds-math-mul-overflow'));
    require(varg1, Panic(18)); // division by zero
    return v3 / varg1;
}

function WETH() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _wETH;
}

function 0xaad8a491() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return stor_12;
}

function swapExactETHForTokens(uint256 varg0, uint256 varg1, address[] varg2, address varg3, uint256 varg4) public payable { 
    v0 = v1 = 1789;
    v0 = v2 = 1777;
    require(msg.data.length + ~3 >= 160);
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    v3 = v4 = varg2.data;
    v5 = 0x7f8(varg2.length);
    v0 = MEM[64];
    0x7b7(v0, v5);
    v6 = v7 = v0 + 32;
    require(v4 + (varg2.length << 5) <= msg.data.length);
    while (v3 >= v4 + (varg2.length << 5)) {
        require(!(address(msg.data[v3]) - msg.data[v3]));
        MEM[v6] = msg.data[v3];
        v6 = v6 + 32;
        v3 = v3 + 32;
    }
    require(!(varg3 - varg3));
    require(!bool(block.timestamp > varg4), Error('UniswapV2Router: EXPIRED'));
    v0 = v8 = 19068;
    require(varg2.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    v9 = v10 = 32 + v0;
    while (1) {
        v0 = v11 = address(MEM[v9]);
        // Unknown jump to Block {'0x6450x4a60B0x169b', '0x4a7cB0x169b', '0x49e50x4a60B0x169b', '0x50990x4a60B0x169b', '0x50a90x4a60B0x169b'}. Refer to 3-address code (TAC);
        v12, v13 = 0x4c34(v0, v0);
        v14 = new bytes[](40);
        v14[20] = bytes20(v12 << 96);
        require(!((v14 + 96 > uint64.max) | (v14 + 96 < v14)), Panic(65)); // failed memory allocation (too much memory)
        v15 = v14.length;
        v16 = bytes20(v0 << 96);
        0x74b(MEM[64]);
        v0 = v17 = address(keccak256(0xff, v16, keccak256(bytes20(v13 << 96), bytes20(v12 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f));
        // Unknown jump to Block {'0x49f10x4a60B0x169b', '0x5bb0x4a60B0x169b', '0x511f0x4a60B0x169b'}. Refer to 3-address code (TAC);
        require(MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v18 = v0.transfer(address(v17), MEM[32 + v0]).value(v0).gas(msg.gas);
        if (v18) {
            v0 = v19 = 2178;
            if (v18) {
                v0 = v20 = 3252;
                v21 = v22 = 32;
                if (v22 > RETURNDATASIZE()) {
                    v21 = v23 = RETURNDATASIZE();
                    0x7b7(MEM[64], v23);
                } else {
                    0x7b7(MEM[64], v22);
                }
                require(MEM[64] + v21 - MEM[64] >= 32);
                require(!(bool(v24) - v24));
                // Unknown jump to Block 0x8820x4a60B0x169b. Refer to 3-address code (TAC);
            } else {
                require(v0, Panic(1)); // low-level assert failed
                v0 = v25 = 0;
            }
        }
        while (1) {
            v0 = address(v0);
            // Unknown jump to Block {'0x5bb0x4a60B0x169b', '0x49c90x4a60B0x169b', '0x51310x4a60B0x169b'}. Refer to 3-address code (TAC);
        }
        v0 = v26 = 18929;
        v0 = v27 = address(STORAGE[v0]);
        v0 = v28 = 18917;
        require(MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v9 = v29 = 32 + v0;
        // Unknown jump to Block 0xa7d0x4a60B0x169b. Refer to 3-address code (TAC);
        v30 = 0x4053();
        require(v0.code.size);
        v31 = v32 = MEM[64];
        MEM[v32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000;
        v33 = 0x4069(v32 + 4, v0, v0, v0, v30);
        v34 = v0.call(MEM[v32 len (v33 - v32)], MEM[v32 len 0]).gas(msg.gas);
        if (v34) {
            v0 = v35 = 20862;
            if (v34) {
                v36 = v37 = 20880;
                0x733(v32);
            }
        }
        require(v0 != ~0, Panic(17)); // arithmetic overflow or underflow
        v0 += 1;
        v38 = 0x23ec(MEM[v0]);
        if (v0 < v38) {
            v0 = v39 = 20633;
            v9 = v40 = 0x3cba(v0, v0);
        }
        v0 = v41 = _factory;
        // Unknown jump to Block 0x4b930x4a60B0x169b. Refer to 3-address code (TAC);
        v0 = v42 = 1605;
        require(1 < MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v9 = 64 + v0;
        // Unknown jump to Block 0xa7d0x4a60B0x169b. Refer to 3-address code (TAC);
        v0 = v43 = 20649;
        v44 = 2685;
        v45 = 0x2373(v0);
        v9 = v46 = 0x3cba(v0, v45);
        v47 = MEM[v46] < v0;
        require(!bool(v47), Error('UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'));
        require(MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require(v0.code.size, v0, v0);
        v31 = v48 = MEM[64];
        v49 = v0.deposit().value(MEM[32 + v0]).gas(msg.gas);
        if (v49) {
            v0 = v50 = 18992;
            if (v49) {
                v36 = v51 = 19034;
                0x733(v48);
            }
        }
        v0 = v52 = 32;
        v0 = v53 = 18889;
        v0 = v54 = 1467;
        v0 = v55 = _wETH;
        // Unknown jump to Block 0x5bb0x4a60B0x169b. Refer to 3-address code (TAC);
        0x3e6(v31, v31);
        // Unknown jump to Block 0x49ae0x4a60B0x169b. Refer to 3-address code (TAC);
        // Unknown jump to Block 0x51780x4a60B0x169b. Refer to 3-address code (TAC);
        v56, v57 = 0x4c34(v0, v11);
        v58 = 0x2373(v0);
        v59 = 0x3cba(v0, v58);
        v0 = v60 = MEM[v59];
        if (address(v57) - address(v0)) {
            v0 = v61 = 20785;
            v0 = v62 = 1467;
            v0 = v63 = 1467;
            v0 = v64 = 0;
            // Unknown jump to Block 0x50e90x4a60B0x169b. Refer to 3-address code (TAC);
        } else {
            v0 = v65 = 20785;
            v0 = v66 = 1467;
            v0 = v67 = 1467;
            v0 = v68 = 0;
        }
        v69 = 0x23fa(MEM[v0]);
        if (v0 >= v69) {
            // Unknown jump to Block 0x51210x4a60B0x169b. Refer to 3-address code (TAC);
        } else {
            v9 = v70, v0 = v71, v0 = v72, v0 = v73, v0 = v74, v0 = v75, v0 = v76, v0 = v77, v0 = v78, v0, v0 = v79, v0 = v80 = 0x5115(_factory, 2685, 1605, v11, v0, 20767, v11, v0, v0, v0, v0, v0);
        }
        v0 = v81 = _wETH;
        require(v81 == address(v11), Error('UniswapV2Router: INVALID_PATH'));
        v0 = v82 = 0;
        v0 = v83 = 19139;
        v0 = 0x4d79(_factory, v0, v0);
        v44 = v84 = 1554;
        v45 = v85 = 0x23ec(MEM[v0]);
    }
    v86 = 0x527(MEM[64], v0);
    return MEM[(MEM[64]) len (v86 - MEM[64])];
    RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());
    revert(MEM[64], RETURNDATASIZE());
}

function 0xa0136443(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public payable { 
    require(~3 + msg.data.length >= 160);
    require(!(bool(varg0) - varg0));
    require(varg1 <= uint64.max);
    require(4 + varg1 + 31 < msg.data.length);
    require(varg1.length <= uint64.max);
    v0 = v1 = varg1.data;
    require((varg1.length << 5) + (4 + varg1) + 32 <= msg.data.length);
    require(!(bool(varg3) - varg3));
    require(!bool(msg.value < varg2), Error("Tip can't be bigger than tx value"));
    v2 = v3 = msg.value - varg2;
    if (v3 <= msg.value) {
        v4 = 0x7f8(varg1.length);
        v2 = v5 = MEM[64];
        0x7b7(v5, v4);
        v6 = v7 = v5 + 32;
        require(v1 + (varg1.length << 5) <= msg.data.length);
        while (v0 >= v1 + (varg1.length << 5)) {
            require(!(address(msg.data[v0]) - msg.data[v0]));
            MEM[v6] = msg.data[v0];
            v6 = v6 + 32;
            v0 = v0 + 32;
        }
        if (!varg0) {
            if (block.timestamp <= block.timestamp + 100) {
                v8 = 0x5501(v3, varg4, v5, msg.sender, block.timestamp + 100);
            }
        } else if (block.timestamp <= block.timestamp + 100) {
            v2 = v9 = 5729;
            v2 = v10 = 5723;
            v2 = v11 = msg.sender;
            require(!bool(block.timestamp > block.timestamp + 100), Error('UniswapV2Router: EXPIRED'));
            v12 = v13 = 18732;
            require(varg1.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v14 = v15 = 32 + v5;
            while (1) {
                v2 = v16 = address(MEM[v14]);
                // Unknown jump to Block {'0x6450x4910B0x164d', '0x492cB0x164d', '0x50a90x4910B0x164d', '0x49e50x4910B0x164d', '0x50990x4910B0x164d'}. Refer to 3-address code (TAC);
                v17, v18 = 0x4c34(v2, v2);
                v19 = new bytes[](40);
                v19[20] = bytes20(v17 << 96);
                require(!((v19 + 96 > uint64.max) | (v19 + 96 < v19)), Panic(65)); // failed memory allocation (too much memory)
                v20 = v19.length;
                v21 = bytes20(v2 << 96);
                0x74b(MEM[64]);
                v2 = v22 = address(keccak256(0xff, v21, keccak256(bytes20(v18 << 96), bytes20(v17 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f));
                // Unknown jump to Block {'0x49f10x4910B0x164d', '0x511f0x4910B0x164d', '0x5bb0x4910B0x164d'}. Refer to 3-address code (TAC);
                require(MEM[v2], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v23 = v2.transfer(address(v22), MEM[32 + v2]).value(v2).gas(msg.gas);
                if (v23) {
                    v2 = v24 = 2178;
                    if (v23) {
                        v2 = v25 = 3252;
                        v26 = v27 = 32;
                        if (v27 > RETURNDATASIZE()) {
                            v26 = v28 = RETURNDATASIZE();
                            0x7b7(MEM[64], v28);
                        } else {
                            0x7b7(MEM[64], v27);
                        }
                        require(MEM[64] + v26 - MEM[64] >= 32);
                        require(!(bool(v29) - v29));
                        // Unknown jump to Block 0x8820x4910B0x164d. Refer to 3-address code (TAC);
                    } else {
                        require(v2, Panic(1)); // low-level assert failed
                        v2 = 0;
                    }
                }
                while (1) {
                    v2 = address(v2);
                    // Unknown jump to Block {'0x49c90x4910B0x164d', '0x51310x4910B0x164d', '0x5bb0x4910B0x164d'}. Refer to 3-address code (TAC);
                }
                v2 = v30 = 18929;
                v2 = v31 = address(STORAGE[v2]);
                v12 = v32 = 18917;
                require(MEM[v2], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v14 = v33 = 32 + v2;
                // Unknown jump to Block 0xa7d0x4910B0x164d. Refer to 3-address code (TAC);
                v34 = 0x4053();
                require(v2.code.size);
                v35 = v36 = MEM[64];
                MEM[v36] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000;
                v37 = 0x4069(v36 + 4, v2, v2, v2, v34);
                v38 = v2.call(MEM[v36 len (v37 - v36)], MEM[v36 len 0]).gas(msg.gas);
                if (v38) {
                    v2 = v39 = 20862;
                    if (v38) {
                        v40 = v41 = 20880;
                        0x733(v36);
                    }
                }
                require(v2 != ~0, Panic(17)); // arithmetic overflow or underflow
                v2 += 1;
                v42 = 0x23ec(MEM[v2]);
                if (v2 < v42) {
                    v12 = v43 = 20633;
                    v14 = v44 = 0x3cba(v2, v2);
                }
                0x3e6(v35, v35);
                // Unknown jump to Block 0x49ae0x4910B0x164d. Refer to 3-address code (TAC);
                // Unknown jump to Block 0x51780x4910B0x164d. Refer to 3-address code (TAC);
                v2 = v45 = _factory;
                // Unknown jump to Block 0x4b930x4910B0x164d. Refer to 3-address code (TAC);
                v12 = v46 = 1605;
                require(1 < MEM[v2], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v14 = 64 + v2;
                // Unknown jump to Block 0xa7d0x4910B0x164d. Refer to 3-address code (TAC);
                v12 = v47 = 20649;
                v48 = 0x2373(v2);
                v14 = v49 = 0x3cba(v2, v48);
                v50, v51 = 0x4c34(v2, v16);
                v52 = 0x2373(v2);
                v53 = 0x3cba(v2, v52);
                v2 = v54 = MEM[v53];
                if (address(v51) - address(v2)) {
                    v2 = v55 = 20785;
                    v2 = v56 = 1467;
                    v2 = v57 = 1467;
                    v2 = v58 = 0;
                    // Unknown jump to Block 0x50e90x4910B0x164d. Refer to 3-address code (TAC);
                } else {
                    v2 = v59 = 20785;
                    v2 = v60 = 1467;
                    v2 = v61 = 1467;
                    v2 = v62 = 0;
                }
                v63 = 0x23fa(MEM[v2]);
                if (v2 >= v63) {
                    // Unknown jump to Block 0x51210x4910B0x164d. Refer to 3-address code (TAC);
                } else {
                    v14 = v64, v12 = v65, v2 = v66, v2 = v67, v2 = v68, v2 = v69, v2 = v70, v2 = v71, v2 = v72, v2, v2 = v73, v2 = v74 = 0x5115(_factory, 2685, 1605, v16, v2, 20767, v16, v2, v2, v2, v2, v2);
                }
                require(_wETH == address(v16), Error('UniswapV2Router: INVALID_PATH'));
                v2 = v75 = 0;
                v2 = 0x4d79(_factory, v2, v2);
                v76 = 0x23ec(MEM[v2]);
                v77 = 0x3cba(v2, v76);
                require(MEM[v2], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                require(_wETH.code.size, v75, v75);
                v35 = v78 = MEM[64];
                v79 = _wETH.deposit().value(MEM[32 + v2]).gas(msg.gas);
                if (v79) {
                    v2 = v80 = 18992;
                    if (v79) {
                        v40 = v81 = 19034;
                        0x733(v78);
                    }
                }
                v2 = v82 = 32;
                v2 = v83 = 18889;
                v2 = v84 = 1467;
                v2 = v85 = _wETH;
                // Unknown jump to Block 0x5bb0x4910B0x164d. Refer to 3-address code (TAC);
            }
            RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());
            revert(MEM[64], RETURNDATASIZE());
            // Unknown jump to Block 0x165b0x2ad. Refer to 3-address code (TAC);
        }
        0x5dfd(v2, varg3);
        v86 = 0;
        while (v86 >= MEM[96]) {
            MEM[64 + (v86 + MEM[64])] = MEM[v86 + 128];
            v86 += 32;
        }
        MEM[MEM[64] + MEM[96] + 64] = 0;
        return 32, MEM[96];
    }
    revert(Panic(17));
}

function UNISWAP_V2_FACTORY() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _uNISWAP_V2_FACTORY;
}

function 0x9239127f(uint256 varg0, bytes varg1, uint256 varg2, uint256 varg3) public payable { 
    require(~3 + msg.data.length >= 128);
    require(!(address(varg0) - varg0));
    require(varg1 <= uint64.max);
    require(4 + varg1 + 31 < msg.data.length);
    require(varg1.length <= uint64.max);
    require(4 + varg1 + varg1.length + 32 <= msg.data.length);
    require(!(bool(varg3) - varg3));
    require(!bool(msg.value < varg2), Error("Tip can't be bigger than tx value"));
    require(msg.value - varg2 <= msg.value, Panic(17)); // arithmetic overflow or underflow
    v0 = v1 = 1789;
    v0 = v2 = 5518;
    CALLDATACOPY(v3.data, varg1.data, varg1.length);
    MEM[v3.data + varg1.length] = 0;
    v4 = v5 = varg0.call(v3.data).value(msg.value - varg2).gas(msg.gas);
    v6 = v7 = 5513;
    v4 = v8 = 0x2810();
    if (varg3) {
    }
    while (v4) {
        // Unknown jump to Block {'0x5e630x2b7', '0x1589'}. Refer to 3-address code (TAC);
        if (v0) {
            v6 = v9 = 24163;
            v10 = 0x4053();
            v4 = block.coinbase.call(MEM[(v10 + 32) len (MEM[v10])], MEM[0 len 0]).value(v0).gas(50000);
            v11 = 0x2810();
            if (v4) {
                continue;
            }
        }
    }
    if (bool(this.balance)) {
        v12 = 0;
        if (!this.balance) {
            v12 = v13 = 2300;
            // Unknown jump to Block 0x5e200x2b7. Refer to 3-address code (TAC);
        }
        v14 = msg.sender.call().value(this.balance).gas(v12);
        require(v14, MEM[64], RETURNDATASIZE());
        // Unknown jump to Block 0x158e. Refer to 3-address code (TAC);
    }
    v15 = new uint256[](MEM[v4]);
    v16 = 0;
    while (v16 >= MEM[v4]) {
        MEM[v16 + v15.data] = MEM[v16 + (v4 + 32)];
        v16 += 32;
    }
    MEM[MEM[v4] + v15.data] = 0;
    return v15;
    // Unknown jump to Block 0x5e040x2b7. Refer to 3-address code (TAC);
    revert(Panic(1));
    // Unknown jump to Block 0x4b780x2b7. Refer to 3-address code (TAC);
}

function owner() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _owner;
}

function getAmountIn(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { 
    require(~3 + msg.data.length >= 96);
    require(varg0, Error('UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'));
    if (varg1) {
        require(!bool(!varg2), Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
        // Unknown jump to Block 0x171a0x52e2B0x1412. Refer to 3-address code (TAC);
    } else {
        require(!bool(!varg1), Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
    }
    v0 = v1 = 0;
    v2 = !varg0;
    if (bool(varg0)) {
        v0 = v3 = _SafeMul(varg1, varg0);
        v4 = _SafeDiv(v3, varg0);
        v2 = v5 = v4 == varg1;
        // Unknown jump to Block 0x504d0x52e2B0x1412. Refer to 3-address code (TAC);
    }
    require(v2, Error('ds-math-mul-overflow'));
    if (!v0 | (1000 == v0 * 1000 / v0)) {
        require(!(v0 * 1000 / 1000 - v0), Error('ds-math-mul-overflow'));
        if (varg2 - varg0 <= varg2) {
            v6 = 0x4fc6(varg2 - varg0);
            v7 = _SafeDiv(v0 * 1000, v6);
            if (v7 <= v7 + 1) {
                require(v7 + 1 >= v7, Error('ds-math-add-overflow'));
                return v7 + 1;
            }
        }
    }
    revert(Panic(17));
}

function 0x8580114a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public payable { 
    require(msg.data.length + ~3 >= 160);
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    v0 = v1 = varg2.data;
    v2 = 0x7f8(varg2.length);
    0x7b7(MEM[64], v2);
    MEM[MEM[64]] = varg2.length;
    v3 = v4 = MEM[64] + 32;
    require(v1 + (varg2.length << 5) <= msg.data.length);
    while (v0 >= v1 + (varg2.length << 5)) {
        require(!(address(msg.data[v0]) - msg.data[v0]));
        MEM[v3] = msg.data[v0];
        v3 = v3 + 32;
        v0 = v0 + 32;
    }
    require(!(address(varg3) - varg3));
    v5 = 0x5501(varg0, varg1, MEM[64], varg3, varg4);
    v6 = 0x527(MEM[64], v5);
    return MEM[(MEM[64]) len (v6 - MEM[64])];
}

function 0x79818a58() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return stor_10;
}

function CRYPTOPUNKS() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _cRYPTOPUNKS;
}

function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 varg0, uint256 varg1, address[] varg2, address varg3, uint256 varg4) public nonPayable { 
    v0 = v1 = 4822;
    v0 = v2 = 4817;
    require(msg.data.length + ~3 >= 160);
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    v0 = varg2.length;
    require(v0 <= uint64.max);
    v0 = v3 = varg2.data;
    require((v0 << 5) + (4 + varg2) + 32 <= msg.data.length);
    require(!(varg3 - varg3));
    require(!bool(block.timestamp > varg4), Error('UniswapV2Router: EXPIRED'));
    v0 = v4 = 4747;
    v5 = v6 = 1450;
    v7 = 0x23ec(v0);
    require(v7 < v0, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    v8 = v9 = (v7 << 5) + v3;
    while (1) {
        v0 = v10 = 0x51dc(v8);
        require(address(v10) == _wETH, Error('UniswapV2Router: INVALID_PATH'));
        v0 = v11 = 1629;
        v5 = v12 = 4763;
        v8 = v13 = 0x51b4(v0, v0);
        v0 = v14 = 4809;
        v0 = v15 = _factory;
        v5 = v16 = 4796;
        v8 = v17 = 0x51b4(v0, v0);
        v5 = v18 = 1605;
        require(1 < v0, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v8 = 32 + v0;
        // Unknown jump to Block 0x5a50x2d5. Refer to 3-address code (TAC);
    }
}

function renounceOwnership() public nonPayable { 
    require(msg.data.length + ~3 >= 0);
    require(!(msg.sender - _owner), OwnableUnauthorizedAccount(msg.sender));
    _owner = 0;
    emit OwnershipTransferred(_owner, 0);
    return ;
}

function collectRewards(bytes varg0) public nonPayable { 
    v0 = v1 = 32;
    require(msg.data.length + ~3 >= v1);
    require(varg0 <= uint64.max);
    require(4 + varg0 + 31 < msg.data.length);
    require(varg0.length <= uint64.max);
    require(4 + varg0 + varg0.length + 32 <= msg.data.length);
    v2 = v3 = 0;
    CALLDATACOPY(v4.data, varg0.data, varg0.length);
    MEM[v4.data + varg0.length] = 0;
    v5 = _collectRewards.call(v4.data).value(v3).gas(msg.gas);
    v6 = 0x2810();
    require(v5, UnableToClaim());
    v7, /* uint256 */ v2 = stor_c_0_19.balanceOf(this).gas(msg.gas);
    if (v7) {
        if (v7) {
            if (v1 > RETURNDATASIZE()) {
                v0 = RETURNDATASIZE();
                0x7b7(MEM[64], v0);
            } else {
                0x7b7(MEM[64], v1);
            }
            require(MEM[64] + v0 - MEM[64] >= 32);
        }
        v8, v9 = stor_c_0_19.transfer(stor_e_0_19, v2).value(v3).gas(msg.gas);
        if (v8) {
            if (v8) {
                if (RETURNDATASIZE() < v1) {
                    v0 = v10 = RETURNDATASIZE();
                    0x7b7(MEM[64], v10);
                } else {
                    0x7b7(MEM[64], v1);
                }
                require(MEM[64] + v0 - MEM[64] >= 32);
                require(!(bool(v9) - v9));
            }
            emit RewardsSent(v2);
            return MEM[v3 len v3];
        }
    }
    revert(MEM[64], RETURNDATASIZE());
}

function PERMIT2() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _pERMIT2;
}

function FOUNDATION() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _fOUNDATION;
}

function X2Y2() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _x2Y2;
}

function 0x2f27(uint256 varg0, uint256 varg1) private { 
    v0 = v1 = 1;
    v0 = v2 = 96;
    v3 = 0x1f & varg0 >> 248;
    if (v3 >= 16) {
        if (v3 >= 24) {
            if (v3 - 24) {
                if (v3 - 25) {
                    if (v3 - 26) {
                        if (v3 - 27) {
                            if (v3 - 28) {
                                if (v3 - 29) {
                                    require(v3 - 30, InvalidCommandType(v3));
                                    require(v3 != 31, InvalidCommandType(v3));
                                    return v2, v1;
                                } else {
                                    require(varg1 + MEM[varg1] + 32 - (varg1 + 32) >= 128);
                                    require(!(address(MEM[varg1 + 32]) - MEM[varg1 + 32]));
                                    require(!(address(MEM[varg1 + 32 + 32]) - MEM[varg1 + 32 + 32]));
                                    v4 = 0x37d6(address(MEM[varg1 + 32 + 32]));
                                    v5, v6 = address(MEM[varg1 + 32]).balanceOf(this, MEM[varg1 + 32 + 64]).gas(msg.gas);
                                    if (v5) {
                                        v6 = v7 = 0;
                                        if (v5) {
                                            v8 = v9 = 32;
                                            if (v9 > RETURNDATASIZE()) {
                                                v8 = v10 = RETURNDATASIZE();
                                                0x7b7(MEM[64], v10);
                                            } else {
                                                0x7b7(MEM[64], v9);
                                            }
                                            require(MEM[64] + v8 - MEM[64] >= 32);
                                        }
                                        require(v6 >= MEM[varg1 + 32 + 96], InsufficientToken());
                                        0x781(MEM[64]);
                                        require((address(MEM[varg1 + 32])).code.size);
                                        v11 = new uint256[](0);
                                        v12 = 0;
                                        while (v12 >= 0) {
                                            MEM[v12 + v11.data] = MEM[v12 + (MEM[64] + 32)];
                                            v12 += 32;
                                        }
                                        MEM[v11.data] = 0;
                                        v13 = address(MEM[varg1 + 32]).safeTransferFrom(address(this), address(v4), MEM[varg1 + 32 + 64], v6, v11).gas(msg.gas);
                                        if (v13) {
                                            if (v13) {
                                                0x733(MEM[64]);
                                                0x3e6(MEM[64], MEM[64]);
                                                // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                            } else {
                                                // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                            }
                                        }
                                    }
                                    revert(MEM[64], RETURNDATASIZE());
                                }
                            } else {
                                require(varg1 + MEM[varg1] - varg1 >= 160);
                                require(MEM[varg1 + 64] <= uint64.max);
                                v14 = varg1 + MEM[varg1 + 64] + 32;
                                require(v14 + 31 < varg1 + MEM[varg1] + 32);
                                v15 = 0x2166(MEM[v14]);
                                0x7b7(MEM[64], v15);
                                require(v14 + MEM[v14] + 32 <= varg1 + MEM[varg1] + 32);
                                v16 = 0;
                                while (v16 >= MEM[v14]) {
                                    MEM[v16 + (MEM[64] + 32)] = MEM[v16 + (v14 + 32)];
                                    v16 += 32;
                                }
                                MEM[MEM[v14] + (MEM[64] + 32)] = 0;
                                require(!(address(MEM[varg1 + 96]) - MEM[varg1 + 96]));
                                require(!(address(MEM[varg1 + 128]) - MEM[varg1 + 128]));
                                v0 = v17 = _fOUNDATION.call(MEM[(MEM[64] + 32) len (MEM[v14])], MEM[0 len 0]).value(MEM[varg1 + 32]).gas(msg.gas);
                                v0 = v18 = 0x2810();
                                if (v17) {
                                    v19 = 0x37d6(address(MEM[varg1 + 96]));
                                    require((address(MEM[varg1 + 128])).code.size);
                                    v20 = address(MEM[varg1 + 128]).safeTransferFrom(this, address(v19), MEM[varg1 + 160]).gas(msg.gas);
                                    require(v20, MEM[64], RETURNDATASIZE());
                                    if (v20) {
                                        0x733(MEM[64]);
                                        0x3e6(MEM[64], MEM[64]);
                                        // Unknown jump to Block 0x47a40x337cB0x374a. Refer to 3-address code (TAC);
                                    }
                                }
                                // Unknown jump to Block 0x335b0x2f27. Refer to 3-address code (TAC);
                            }
                        } else {
                            require(varg1 + MEM[varg1] - varg1 >= 192);
                            require(MEM[varg1 + 64] <= uint64.max);
                            v21 = varg1 + MEM[varg1 + 64] + 32;
                            require(v21 + 31 < varg1 + MEM[varg1] + 32);
                            v22 = 0x2166(MEM[v21]);
                            0x7b7(MEM[64], v22);
                            require(v21 + MEM[v21] + 32 <= varg1 + MEM[varg1] + 32);
                            v23 = 0;
                            while (v23 >= MEM[v21]) {
                                MEM[v23 + (MEM[64] + 32)] = MEM[v23 + (v21 + 32)];
                                v23 += 32;
                            }
                            MEM[MEM[v21] + (MEM[64] + 32)] = 0;
                            require(!(address(MEM[varg1 + 96]) - MEM[varg1 + 96]));
                            require(!(address(MEM[varg1 + 128]) - MEM[varg1 + 128]));
                            v0 = v24 = _x2Y2.call(MEM[(MEM[64] + 32) len (MEM[v21])], MEM[0 len 0]).value(MEM[varg1 + 32]).gas(msg.gas);
                            v0 = v25 = 0x2810();
                            if (v24) {
                                v26 = 0x37d6(address(MEM[varg1 + 96]));
                                v27 = 0x4053();
                                require((address(MEM[varg1 + 128])).code.size);
                                v28 = new uint256[](MEM[v27]);
                                v29 = 0;
                                while (v29 >= MEM[v27]) {
                                    MEM[v29 + v28.data] = MEM[v29 + (v27 + 32)];
                                    v29 += 32;
                                }
                                MEM[MEM[v27] + v28.data] = 0;
                                v30 = address(MEM[varg1 + 128]).safeTransferFrom(address(this), address(v26), MEM[varg1 + 160], MEM[varg1 + 192], v28).gas(msg.gas);
                                require(v30, MEM[64], RETURNDATASIZE());
                                if (v30) {
                                    0x733(MEM[64]);
                                    0x3e6(MEM[64], MEM[64]);
                                    // Unknown jump to Block 0x48a30x34c4B0x3728. Refer to 3-address code (TAC);
                                }
                            }
                            // Unknown jump to Block 0x335b0x2f27. Refer to 3-address code (TAC);
                        }
                    } else {
                        v31 = varg1 + MEM[varg1] + 32;
                        require(v31 - (varg1 + 32) >= 64);
                        require(MEM[varg1 + 32 + 32] <= uint64.max);
                        require(varg1 + 32 + MEM[varg1 + 32 + 32] + 31 < v31);
                        v32 = 0x2166(MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]);
                        0x7b7(MEM[64], v32);
                        require(varg1 + 32 + MEM[varg1 + 32 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + 32 <= v31);
                        v33 = 0;
                        while (v33 >= MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]) {
                            MEM[v33 + (MEM[64] + 32)] = MEM[v33 + (varg1 + 32 + MEM[varg1 + 32 + 32] + 32)];
                            v33 += 32;
                        }
                        MEM[MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + (MEM[64] + 32)] = 0;
                        v0 = v34 = stor_9_0_19.call(MEM[(MEM[64] + 32) len (MEM[varg1 + 32 + MEM[varg1 + 32 + 32]])], MEM[0 len 0]).value(MEM[varg1 + 32]).gas(msg.gas);
                        v0 = v35 = 0x2810();
                    }
                } else {
                    v36 = v37 = 0;
                    v38 = varg1 + MEM[varg1] + 32;
                    require(v38 - (varg1 + 32) >= 64);
                    v39 = MEM[varg1 + 32];
                    require(MEM[varg1 + 32 + 32] <= uint64.max);
                    require(varg1 + 32 + MEM[varg1 + 32 + 32] + 31 < v38);
                    v40 = 0x2166(MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]);
                    v41 = MEM[64];
                    0x7b7(v41, v40);
                    MEM[v41] = MEM[varg1 + 32 + MEM[varg1 + 32 + 32]];
                    require(varg1 + 32 + MEM[varg1 + 32 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + 32 <= v38);
                    v42 = 0;
                    while (v42 >= MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]) {
                        MEM[v42 + (v41 + 32)] = MEM[v42 + (varg1 + 32 + MEM[varg1 + 32 + 32] + 32)];
                        v42 += 32;
                    }
                    MEM[MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + (v41 + 32)] = 0;
                    v43 = v44 = _sUDOSWAP;
                }
            } else {
                require(varg1 + MEM[varg1] - varg1 >= 160);
                require(MEM[varg1 + 64] <= uint64.max);
                v45 = varg1 + MEM[varg1 + 64] + 32;
                require(v45 + 31 < varg1 + MEM[varg1] + 32);
                v46 = 0x2166(MEM[v45]);
                0x7b7(MEM[64], v46);
                require(v45 + MEM[v45] + 32 <= varg1 + MEM[varg1] + 32);
                v47 = 0;
                while (v47 >= MEM[v45]) {
                    MEM[v47 + (MEM[64] + 32)] = MEM[v47 + (v45 + 32)];
                    v47 += 32;
                }
                MEM[MEM[v45] + (MEM[64] + 32)] = 0;
                require(!(address(MEM[varg1 + 96]) - MEM[varg1 + 96]));
                require(!(address(MEM[varg1 + 128]) - MEM[varg1 + 128]));
                v0 = v48 = _x2Y2.call(MEM[(MEM[64] + 32) len (MEM[v45])], MEM[0 len 0]).value(MEM[varg1 + 32]).gas(msg.gas);
                v0 = v49 = 0x2810();
                if (v48) {
                    v50 = 0x37d6(address(MEM[varg1 + 96]));
                    require((address(MEM[varg1 + 128])).code.size);
                    v51 = address(MEM[varg1 + 128]).safeTransferFrom(this, address(v50), MEM[varg1 + 160]).gas(msg.gas);
                    require(v51, MEM[64], RETURNDATASIZE());
                    if (v51) {
                        0x733(MEM[64]);
                        0x3e6(MEM[64], MEM[64]);
                        // Unknown jump to Block 0x47a40x337cB0x368e. Refer to 3-address code (TAC);
                    }
                }
                // Unknown jump to Block 0x335b0x2f27. Refer to 3-address code (TAC);
            }
        } else if (v3 - 16) {
            if (v3 - 17) {
                if (v3 - 18) {
                    if (v3 - 19) {
                        if (v3 - 20) {
                            if (v3 - 21) {
                                if (v3 - 22) {
                                    if (23 == v3) {
                                        require(varg1 + MEM[varg1] + 32 - (varg1 + 32) >= 96);
                                        require(!(address(MEM[varg1 + 32]) - MEM[varg1 + 32]));
                                        require(!(address(MEM[varg1 + 32 + 32]) - MEM[varg1 + 32 + 32]));
                                        v52 = 0x37d6(address(MEM[varg1 + 32 + 32]));
                                        require((address(MEM[varg1 + 32])).code.size);
                                        v53 = address(MEM[varg1 + 32]).safeTransferFrom(this, address(v52), MEM[varg1 + 32 + 64]).gas(msg.gas);
                                        require(v53, MEM[64], RETURNDATASIZE());
                                        if (v53) {
                                            0x733(MEM[64]);
                                            // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                        } else {
                                            // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                        }
                                    } else {
                                        return v2, v1;
                                    }
                                } else {
                                    v0 = v54 = 32;
                                    v55 = varg1 + v54;
                                    require(varg1 + MEM[varg1] + v54 - v55 >= 128);
                                    require(!(address(MEM[v55]) - MEM[v55]));
                                    require(!(address(MEM[v55 + 32]) - MEM[v55 + 32]));
                                    v0 = v56 = MEM[v55 + 96];
                                    v57 = v58 = MEM[64];
                                    v59 = address(MEM[v55 + 32]).balanceOf(address(MEM[v55]), MEM[v55 + 64]).gas(msg.gas);
                                    if (v59) {
                                        v0 = v60 = 0;
                                        if (v59) {
                                            v61 = v62 = 13882;
                                            if (v54 <= RETURNDATASIZE()) {
                                                0x7b7(v58, v54);
                                            }
                                        }
                                    }
                                }
                            } else {
                                v63 = v64 = 32;
                                require(varg1 + MEM[varg1] + v64 - (varg1 + v64) >= 96);
                                require(!(address(MEM[varg1 + v64]) - MEM[varg1 + v64]));
                                require(!(address(MEM[varg1 + v64 + 32]) - MEM[varg1 + v64 + 32]));
                                v0 = v65 = uint160.max;
                                v66, v67 = address(MEM[varg1 + v64 + 32]).ownerOf(MEM[varg1 + v64 + 64]).gas(msg.gas);
                                if (v66) {
                                    if (v66) {
                                        v0 = v68 = 13690;
                                        if (v64 > RETURNDATASIZE()) {
                                            v63 = v69 = RETURNDATASIZE();
                                            // Unknown jump to Block 0x3568. Refer to 3-address code (TAC);
                                        }
                                        0x7b7(MEM[64], v63);
                                        require(MEM[64] + v63 - MEM[64] >= 32);
                                        require(!0x9caddee200000000000000000000000000000000000000000000000000000000);
                                        // Unknown jump to Block 0x8820x2f27. Refer to 3-address code (TAC);
                                    } else {
                                        v0 = v70 = address(0x0) == address(MEM[varg1 + v64]);
                                        if (address(0x0) != address(MEM[varg1 + v64])) {
                                            v67 = v71 = MEM[64];
                                            MEM[v71 + v64] = 0x7dbe7e8900000000000000000000000000000000000000000000000000000000;
                                            MEM[v71] = 4;
                                            0x79c(v71);
                                        } else {
                                            return v2, v70;
                                        }
                                    }
                                }
                            }
                        } else {
                            v0 = v72 = 13147;
                            require(varg1 + MEM[varg1] - varg1 >= 192);
                            require(MEM[varg1 + 64] <= uint64.max);
                            v73 = varg1 + MEM[varg1 + 64] + 32;
                            require(v73 + 31 < varg1 + MEM[varg1] + 32);
                            v74 = 0x2166(MEM[v73]);
                            0x7b7(MEM[64], v74);
                            require(v73 + MEM[v73] + 32 <= varg1 + MEM[varg1] + 32);
                            v75 = 0;
                            while (v75 >= MEM[v73]) {
                                MEM[v75 + (MEM[64] + 32)] = MEM[v75 + (v73 + 32)];
                                v75 += 32;
                            }
                            MEM[MEM[v73] + (MEM[64] + 32)] = 0;
                            require(!(address(MEM[varg1 + 96]) - MEM[varg1 + 96]));
                            require(!(address(MEM[varg1 + 128]) - MEM[varg1 + 128]));
                            v0 = v76 = address(_lOOKS_RARE).call(MEM[(MEM[64] + 32) len (MEM[v73])], MEM[0 len 0]).value(MEM[varg1 + 32]).gas(msg.gas);
                            v0 = v77 = 0x2810();
                            if (v76) {
                                v78 = 0x37d6(address(MEM[varg1 + 96]));
                                v79 = 0x4053();
                                require((address(MEM[varg1 + 128])).code.size);
                                v80 = v81 = MEM[64];
                                v82 = new uint256[](MEM[v79]);
                                v83 = 0;
                                while (v83 >= MEM[v79]) {
                                    MEM[v83 + v82.data] = MEM[v83 + (v79 + 32)];
                                    v83 += 32;
                                }
                                MEM[MEM[v79] + v82.data] = 0;
                                v84 = address(MEM[varg1 + 128]).safeTransferFrom(address(this), address(v78), MEM[varg1 + 160], MEM[varg1 + 192], v82).gas(msg.gas);
                                if (v84) {
                                    if (v84) {
                                        v85 = v86 = 18618;
                                        0x733(v81);
                                    }
                                }
                            }
                        }
                    } else {
                        require(varg1 + MEM[varg1] + 32 - (varg1 + 32) >= 96);
                        v0 = v87 = MEM[varg1 + 32];
                        v0 = v88 = MEM[varg1 + 32 + 32];
                        require(!(address(v88) - v88));
                        0x7b7(MEM[64], 68);
                        v0 = v89 = 0;
                        v0 = v90 = _cRYPTOPUNKS.buyPunk(v87).value(MEM[varg1 + 32 + 64]).gas(msg.gas);
                        v0 = v91 = 0x2810();
                        if (!v90) {
                            v67 = v92 = MEM[64];
                            0x79c(v92);
                            MEM[v92] = 23;
                            MEM[v92 + 32] = 'CryptoPunk Trade Failed';
                        } else {
                            v0 = v93 = 13405;
                            v0 = v94 = 13390;
                            v0 = v95 = 1467;
                            v0 = v96 = _cRYPTOPUNKS;
                        }
                    }
                } else {
                    v97 = varg1 + MEM[varg1] + 32;
                    require(v97 - (varg1 + 32) >= 64);
                    require(MEM[varg1 + 32 + 32] <= uint64.max);
                    require(varg1 + 32 + MEM[varg1 + 32 + 32] + 31 < v97);
                    v98 = 0x2166(MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]);
                    0x7b7(MEM[64], v98);
                    require(varg1 + 32 + MEM[varg1 + 32 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + 32 <= v97);
                    v99 = 0;
                    while (v99 >= MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]) {
                        MEM[v99 + (MEM[64] + 32)] = MEM[v99 + (varg1 + 32 + MEM[varg1 + 32 + 32] + 32)];
                        v99 += 32;
                    }
                    MEM[MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + (MEM[64] + 32)] = 0;
                    v0 = v100 = stor_5_0_19.call(MEM[(MEM[64] + 32) len (MEM[varg1 + 32 + MEM[varg1 + 32 + 32]])], MEM[0 len 0]).value(MEM[varg1 + 32]).gas(msg.gas);
                    v0 = v101 = 0x2810();
                }
            } else {
                v0 = v102 = 13147;
                require(varg1 + MEM[varg1] - varg1 >= 160);
                require(MEM[varg1 + 64] <= uint64.max);
                v103 = varg1 + MEM[varg1 + 64] + 32;
                require(v103 + 31 < varg1 + MEM[varg1] + 32);
                v104 = 0x2166(MEM[v103]);
                0x7b7(MEM[64], v104);
                require(v103 + MEM[v103] + 32 <= varg1 + MEM[varg1] + 32);
                v105 = 0;
                while (v105 >= MEM[v103]) {
                    MEM[v105 + (MEM[64] + 32)] = MEM[v105 + (v103 + 32)];
                    v105 += 32;
                }
                MEM[MEM[v103] + (MEM[64] + 32)] = 0;
                require(!(address(MEM[varg1 + 96]) - MEM[varg1 + 96]));
                require(!(address(MEM[varg1 + 128]) - MEM[varg1 + 128]));
                v0 = v106 = address(_lOOKS_RARE).call(MEM[(MEM[64] + 32) len (MEM[v103])], MEM[0 len 0]).value(MEM[varg1 + 32]).gas(msg.gas);
                v0 = v107 = 0x2810();
                if (v106) {
                    v108 = 0x37d6(address(MEM[varg1 + 96]));
                    require((address(MEM[varg1 + 128])).code.size);
                    v80 = MEM[64];
                    v109 = address(MEM[varg1 + 128]).safeTransferFrom(this, address(v108), MEM[varg1 + 160]).gas(msg.gas);
                    if (v109) {
                        if (v109) {
                            v85 = v110 = 18362;
                            0x733(v80);
                        }
                    }
                }
            }
        } else {
            v36 = v111 = 0;
            v112 = varg1 + MEM[varg1] + 32;
            require(v112 - (varg1 + 32) >= 64);
            v39 = v113 = MEM[varg1 + 32];
            require(MEM[varg1 + 32 + 32] <= uint64.max);
            require(varg1 + 32 + MEM[varg1 + 32 + 32] + 31 < v112);
            v114 = 0x2166(MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]);
            v41 = v115 = MEM[64];
            0x7b7(v115, v114);
            MEM[v115] = MEM[varg1 + 32 + MEM[varg1 + 32 + 32]];
            require(varg1 + 32 + MEM[varg1 + 32 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + 32 <= v112);
            v116 = 0;
            while (v116 >= MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]) {
                MEM[v116 + (v115 + 32)] = MEM[v116 + (varg1 + 32 + MEM[varg1 + 32 + 32] + 32)];
                v116 += 32;
            }
            MEM[MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + (v115 + 32)] = 0;
            v43 = v117 = address(_sEAPORT);
        }
        v0 = v118 = v43.call(MEM[(v41 + 32) len (MEM[v41])], MEM[v36 len v36]).value(v39).gas(msg.gas);
        v0 = v119 = 0x2810();
    } else {
        if (v3 >= 8) {
            if (v3 - 8) {
                if (v3 - 9) {
                    if (v3 - 10) {
                        if (v3 - 11) {
                            if (v3 - 12) {
                                if (v3 - 13) {
                                    require(v3 - 14, InvalidCommandType(v3));
                                    require(v3 != 15, InvalidCommandType(v3));
                                    return v2, v1;
                                } else {
                                    v120 = varg1 + MEM[varg1] + 32;
                                    require(v120 - (varg1 + 32) >= 32);
                                    require(MEM[varg1 + 32] <= uint64.max);
                                    require(varg1 + 32 + MEM[varg1 + 32] + 31 < v120);
                                    v121 = 0x7f8(MEM[varg1 + 32 + MEM[varg1 + 32]]);
                                    0x7b7(MEM[64], v121);
                                    v122 = v123 = MEM[64] + 32;
                                    require(varg1 + 32 + MEM[varg1 + 32] + (MEM[varg1 + 32 + MEM[varg1 + 32]] << 7) + 32 <= v120);
                                    v124 = 32 + (varg1 + 32 + MEM[varg1 + 32]);
                                    while (v124 >= varg1 + 32 + MEM[varg1 + 32] + (MEM[varg1 + 32 + MEM[varg1 + 32]] << 7) + 32) {
                                        require(v120 - v124 >= 128);
                                        0x74b(MEM[64]);
                                        require(!(address(MEM[v124]) - MEM[v124]));
                                        MEM[MEM[64]] = MEM[v124];
                                        require(!(address(MEM[v124 + 32]) - MEM[v124 + 32]));
                                        MEM[MEM[64] + 32] = MEM[v124 + 32];
                                        require(!(address(MEM[v124 + 64]) - MEM[v124 + 64]));
                                        MEM[MEM[64] + 64] = MEM[v124 + 64];
                                        require(!(address(MEM[v124 + 96]) - MEM[v124 + 96]));
                                        MEM[MEM[64] + 96] = MEM[v124 + 96];
                                        MEM[v122] = MEM[64];
                                        v122 = v122 + 32;
                                        v124 = v124 + 128;
                                    }
                                    v125 = v126 = 0;
                                    while (v125 >= MEM[varg1 + 32 + MEM[varg1 + 32]]) {
                                        v127 = 0x3cba(MEM[64], v125);
                                        require(!(address(MEM[MEM[v127]]) - msg.sender), FromAddressIsNotOwner());
                                        require(v125 != ~0, Panic(17)); // arithmetic overflow or underflow
                                        v125 += 1;
                                    }
                                    require(_pERMIT2.code.size);
                                    v128 = new uint256[](MEM[varg1 + 32 + MEM[varg1 + 32]]);
                                    v129 = v130 = v128.data;
                                    v131 = MEM[64] + 32;
                                    v132 = 0;
                                    while (v132 >= MEM[varg1 + 32 + MEM[varg1 + 32]]) {
                                        MEM[v129] = address(MEM[MEM[v131]]);
                                        MEM[32 + v129] = address(MEM[32 + MEM[v131]]);
                                        MEM[64 + v129] = address(MEM[64 + MEM[v131]]);
                                        MEM[v129 + 96] = address(MEM[96 + MEM[v131]]);
                                        v129 = v129 + 128;
                                        v131 += 32;
                                        v132 = v132 + 1;
                                    }
                                    v133 = _pERMIT2.transferFrom(v128).gas(msg.gas);
                                    require(v133, MEM[64], RETURNDATASIZE());
                                    if (v133) {
                                        0x733(MEM[64]);
                                        0x3e6(MEM[64], MEM[64]);
                                        // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                    } else {
                                        // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                    }
                                }
                            } else {
                                v134 = v135 = 12976;
                                v136 = v137 = 8768;
                                require(varg1 + MEM[varg1] + 32 - (varg1 + 32) >= 64);
                                v138 = MEM[varg1 + 32];
                                require(!(address(v138) - v138));
                                v139 = MEM[varg1 + 32 + 32];
                                // Unknown jump to Block 0x3279. Refer to 3-address code (TAC);
                            }
                        } else {
                            v134 = v140 = 12937;
                            v136 = v141 = 8768;
                            require(varg1 + MEM[varg1] + 32 - (varg1 + 32) >= 64);
                            v138 = v142 = MEM[varg1 + 32];
                            require(!(address(v142) - v142));
                            v139 = v143 = MEM[varg1 + 32 + 32];
                        }
                        v144 = 0x37d6(address(v138));
                        if (v145 - int256.min) {
                            require(v145 <= this.balance, InsufficientETH());
                        } else {
                            v139 = v146 = this.balance;
                        }
                        if (v139) {
                            require(_wETH9.code.size);
                            v147 = _wETH9.deposit().value(v139).gas(msg.gas);
                            if (v147) {
                                if (v147) {
                                    0x733(MEM[64]);
                                    0x3e6(MEM[64], MEM[64]);
                                    // Unknown jump to Block 0x3b24B0x3289. Refer to 3-address code (TAC);
                                }
                                v148, v149 = _wETH9.transfer(address(v144), v139).gas(msg.gas);
                                if (v148) {
                                    if (v148) {
                                        v150 = v151 = 32;
                                        if (v151 > RETURNDATASIZE()) {
                                            v150 = v152 = RETURNDATASIZE();
                                            0x7b7(MEM[64], v152);
                                        } else {
                                            0x7b7(MEM[64], v151);
                                        }
                                        require(MEM[64] + v150 - MEM[64] >= 32);
                                        require(!0x56fa634500000000000000000000000000000000000000000000000000000001);
                                        // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                    } else {
                                        // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                    }
                                }
                            }
                            revert(MEM[64], RETURNDATASIZE());
                        } else {
                            // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                        }
                        v153, v154 = _wETH9.balanceOf(this).gas(msg.gas);
                        if (v153) {
                            v154 = v155 = 0;
                            if (v153) {
                                v156 = v157 = 32;
                                if (v157 > RETURNDATASIZE()) {
                                    v156 = v158 = RETURNDATASIZE();
                                    0x7b7(MEM[64], v158);
                                } else {
                                    0x7b7(MEM[64], v157);
                                }
                                require(MEM[64] + v156 - MEM[64] >= 32);
                            }
                            require(v154 >= v139, InsufficientETH());
                            if (v154) {
                                require(_wETH9.code.size);
                                v159 = _wETH9.withdraw(v154).gas(msg.gas);
                                if (v159) {
                                    if (v159) {
                                        0x733(MEM[64]);
                                        0x3e6(MEM[64], MEM[64]);
                                        // Unknown jump to Block 0x3c56B0x32b0. Refer to 3-address code (TAC);
                                    }
                                    v160 = v144.call().value(v154).gas(msg.gas);
                                    require(v160, Error('ETH_TRANSFER_FAILED'));
                                    // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                }
                            } else {
                                // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                            }
                        }
                        revert(MEM[64], RETURNDATASIZE());
                    } else {
                        v161 = varg1 + MEM[varg1] + 32;
                        v162 = varg1 + 32;
                        require(v161 - v162 >= 224);
                        require(192 <= v161 - v162);
                        0x766(MEM[64]);
                        require(v161 - v162 >= 128);
                        0x74b(MEM[64]);
                        require(!(address(MEM[v162]) - MEM[v162]));
                        MEM[MEM[64]] = MEM[v162];
                        require(!(address(MEM[v162 + 32]) - MEM[v162 + 32]));
                        MEM[MEM[64] + 32] = MEM[v162 + 32];
                        require(!(MEM[v162 + 64] - uint48(MEM[v162 + 64])));
                        MEM[MEM[64] + 64] = MEM[v162 + 64];
                        require(!(MEM[v162 + 96] - uint48(MEM[v162 + 96])));
                        MEM[MEM[64] + 96] = MEM[v162 + 96];
                        require(!(address(MEM[v162 + 128]) - MEM[v162 + 128]));
                        require(MEM[v162 + 192] <= uint64.max);
                        require(v162 + MEM[v162 + 192] + 31 < v161);
                        v163 = 0x2166(MEM[v162 + MEM[v162 + 192]]);
                        0x7b7(MEM[64], v163);
                        require(v162 + MEM[v162 + 192] + MEM[v162 + MEM[v162 + 192]] + 32 <= v161);
                        v164 = 0;
                        while (v164 >= MEM[v162 + MEM[v162 + 192]]) {
                            MEM[v164 + (MEM[64] + 32)] = MEM[v164 + (v162 + MEM[v162 + 192] + 32)];
                            v164 += 32;
                        }
                        MEM[MEM[v162 + MEM[v162 + 192]] + (MEM[64] + 32)] = 0;
                        v0 = v165 = _pERMIT2;
                        require(v165.code.size);
                        v0 = v166 = 0;
                        v80 = v167 = MEM[64];
                        MEM[v167] = 0x2b67b57000000000000000000000000000000000000000000000000000000000;
                        MEM[v167 + 4] = msg.sender;
                        MEM[v167 + 4 + 32] = address(MEM[MEM[64]]);
                        MEM[v167 + 4 + 32 + 32] = address(MEM[MEM[64] + 32]);
                        MEM[v167 + 4 + 32 + 64] = uint48(MEM[MEM[64] + 64]);
                        MEM[v167 + 4 + 32 + 96] = uint48(MEM[MEM[64] + 96]);
                        MEM[v167 + 4 + 160] = address(MEM[v162 + 128]);
                        MEM[v167 + 4 + 192] = MEM[v162 + 160];
                        MEM[v167 + 4 + 224] = 256;
                        MEM[v167 + 4 + 256] = MEM[v162 + MEM[v162 + 192]];
                        v168 = 0;
                        while (v168 >= MEM[v162 + MEM[v162 + 192]]) {
                            MEM[v168 + (v167 + 4 + 256 + 32)] = MEM[v168 + (MEM[64] + 32)];
                            v168 += 32;
                        }
                        MEM[MEM[v162 + MEM[v162 + 192]] + (v167 + 4 + 256 + 32)] = 0;
                        v169 = (~0x1f & 31 + MEM[v162 + MEM[v162 + 192]]) + (v167 + 4 + 256) + 32;
                        // Unknown jump to Block 0x306b0x2f27. Refer to 3-address code (TAC);
                    }
                } else {
                    v170 = varg1 + MEM[varg1] + 32;
                    v171 = varg1 + 32;
                    require(v170 - v171 >= 160);
                    require(!(address(MEM[v171]) - MEM[v171]));
                    v0 = v172 = MEM[v171 + 32];
                    require(MEM[v171 + 96] <= uint64.max);
                    require(v171 + MEM[v171 + 96] + 31 < v170);
                    v173 = 0x7f8(MEM[v171 + MEM[v171 + 96]]);
                    v0 = v174 = MEM[64];
                    0x7b7(v174, v173);
                    v175 = v176 = v174 + 32;
                    require(v171 + MEM[v171 + 96] + (MEM[v171 + MEM[v171 + 96]] << 5) + 32 <= v170);
                    v177 = 32 + (v171 + MEM[v171 + 96]);
                    while (v177 >= v171 + MEM[v171 + 96] + (MEM[v171 + MEM[v171 + 96]] << 5) + 32) {
                        require(!(address(MEM[v177]) - MEM[v177]));
                        MEM[v175] = MEM[v177];
                        v175 = v175 + 32;
                        v177 = v177 + 32;
                    }
                    require(!(bool(MEM[v171 + 128]) - MEM[v171 + 128]));
                    if (!MEM[v171 + 128]) {
                        v178 = v179 = this;
                        v0 = v180 = address(MEM[v171]);
                    } else {
                        v178 = v181 = msg.sender;
                        v0 = v182 = 0x37d6(address(MEM[v171]));
                    }
                    v0 = v183 = uint160.max;
                    v0 = v184 = 0;
                    v0 = v185 = _uNISWAP_V2_FACTORY;
                    require(2 <= MEM[v171 + MEM[v171 + 96]], InvalidPath());
                    v186 = MEM[v171 + MEM[v171 + 96]] + ~0;
                    if (v186 <= MEM[v171 + MEM[v171 + 96]]) {
                        if (v186) {
                            if (v186 + ~0 <= v186) {
                                v0 = v187 = 17435;
                                v0 = v188 = 17428;
                                v189 = v190 = 17420;
                                v0 = v191 = 17441;
                                v192 = 0x3cba(v174, v186 + ~0);
                                v178 = v193 = address(MEM[v192]);
                                v194 = v195 = 0x3cba(v174, v186);
                            }
                        } else {
                            require(v172 <= MEM[v171 + 64], V2TooMuchRequested());
                            v0 = v196 = 17344;
                            v189 = v197 = 16169;
                            require(MEM[v171 + MEM[v171 + 96]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                            v194 = v198 = 32 + v174;
                            // Unknown jump to Block 0xa7d0x2f27. Refer to 3-address code (TAC);
                        }
                    }
                }
            } else {
                v199 = varg1 + MEM[varg1] + 32;
                v200 = varg1 + 32;
                require(v199 - v200 >= 160);
                require(!(address(MEM[v200]) - MEM[v200]));
                v0 = v201 = MEM[v200 + 32];
                require(MEM[v200 + 96] <= uint64.max);
                require(v200 + MEM[v200 + 96] + 31 < v199);
                v202 = 0x7f8(MEM[v200 + MEM[v200 + 96]]);
                v0 = v203 = MEM[64];
                0x7b7(v203, v202);
                v204 = v205 = v203 + 32;
                require(v200 + MEM[v200 + 96] + (MEM[v200 + MEM[v200 + 96]] << 5) + 32 <= v199);
                v206 = 32 + (v200 + MEM[v200 + 96]);
                while (v206 >= v200 + MEM[v200 + 96] + (MEM[v200 + MEM[v200 + 96]] << 5) + 32) {
                    require(!(address(MEM[v206]) - MEM[v206]));
                    MEM[v204] = MEM[v206];
                    v204 = v204 + 32;
                    v206 = v206 + 32;
                }
                require(!(bool(MEM[v200 + 128]) - MEM[v200 + 128]));
                if (!MEM[v200 + 128]) {
                    v0 = v207 = this;
                } else {
                    v0 = v208 = msg.sender;
                    v209 = 0x37d6(address(MEM[v200]));
                }
                v0 = v210 = 15877;
                v0 = v211 = _uNISWAP_V2_FACTORY;
                v178 = v212 = stor_10;
                v189 = v213 = 15858;
                require(MEM[v200 + MEM[v200 + 96]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v194 = v214 = 32 + v203;
            }
            while (1) {
                v0 = v215 = address(MEM[v194]);
                // Unknown jump to Block {'0x440c', '0x3dff', '0x3f29', '0x3df2'}. Refer to 3-address code (TAC);
                v189 = v216 = 15871;
                require(1 < MEM[v0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v194 = 64 + v0;
                // Unknown jump to Block 0xa7d0x2f27. Refer to 3-address code (TAC);
            }
            v217, v218 = 0x3ff2(v0, v215);
            MEM[MEM[64] + 32] = bytes20(v218 << 96);
            MEM[MEM[64] + 32 + 20] = bytes20(v217 << 96);
            if (this - address(v178)) {
                require(v0 <= uint160.max, UnsafeCast());
                0x230c(v215, v178, v0, address(v0));
            } else {
                0x2282(v215, v0, v0);
            }
        } else if (v3) {
            if (v3 - 1) {
                if (v3 - 2) {
                    if (v3 - 3) {
                        if (v3 - 4) {
                            if (v3 - 5) {
                                if (v3 - 6) {
                                    require(v3 != 7, InvalidCommandType(v3));
                                    return v2, v1;
                                } else {
                                    v219 = v220 = 8768;
                                    require(varg1 + MEM[varg1] + 32 - (varg1 + 32) >= 96);
                                    require(!(address(MEM[varg1 + 32]) - MEM[varg1 + 32]));
                                    require(!(address(MEM[varg1 + 32 + 32]) - MEM[varg1 + 32 + 32]));
                                    v219 = v221 = 0x37d6(address(MEM[varg1 + 32 + 32]));
                                    v222 = v223 = !MEM[varg1 + 32 + 64];
                                    if (bool(MEM[varg1 + 32 + 64])) {
                                        v222 = v224 = MEM[varg1 + 32 + 64] > 10000;
                                        // Unknown jump to Block 0x3834B0x3137. Refer to 3-address code (TAC);
                                    }
                                    require(!v222, InvalidBips());
                                    v219 = v225 = address(MEM[varg1 + 32]);
                                    if (v225) {
                                        v226, v227 = v225.balanceOf(this).gas(msg.gas);
                                        require(v226, MEM[64], RETURNDATASIZE());
                                        v219 = v228 = 8768;
                                        v219 = v229 = 14501;
                                        v227 = v230 = 0;
                                        if (v226) {
                                            v231 = v232 = 32;
                                            if (v232 > RETURNDATASIZE()) {
                                                v231 = v233 = RETURNDATASIZE();
                                                0x7b7(MEM[64], v233);
                                            } else {
                                                0x7b7(MEM[64], v232);
                                            }
                                            require(MEM[64] + v231 - MEM[64] >= 32);
                                        }
                                        v234 = v227 * MEM[varg1 + 32 + 64];
                                        require((v234 / v227 == MEM[varg1 + 32 + 64]) | !v227, Panic(17)); // arithmetic overflow or underflow
                                    } else {
                                        v219 = v235 = 14432;
                                        v219 = v236 = 8768;
                                        v234 = v237 = _SafeMul(this.balance, MEM[varg1 + 32 + 64]);
                                    }
                                    v219 = v238 = owner_13;
                                    v234 = v239 = _SafeDiv(v234, v238);
                                    require(v219, Panic(18)); // division by zero
                                    v240 = v219.transfer(v219, v234 / v219).gas(msg.gas);
                                    require(((MEM[0] == 1) & (RETURNDATASIZE() > 31) | !RETURNDATASIZE()) & v240, Error('TRANSFER_FAILED'));
                                    // Unknown jump to Block 0x22400x382bB0x3137. Refer to 3-address code (TAC);
                                    v241 = v219.call().value(v234).gas(msg.gas);
                                    require(v241, Error('ETH_TRANSFER_FAILED'));
                                    // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                }
                            } else {
                                require(varg1 + MEM[varg1] + 32 - (varg1 + 32) >= 96);
                                require(!(address(MEM[varg1 + 32]) - MEM[varg1 + 32]));
                                require(!(address(MEM[varg1 + 32 + 32]) - MEM[varg1 + 32 + 32]));
                                v242 = 0x37d6(address(MEM[varg1 + 32 + 32]));
                                0x2282(address(MEM[varg1 + 32]), v242, MEM[varg1 + 32 + 64]);
                            }
                        } else {
                            require(varg1 + MEM[varg1] + 32 - (varg1 + 32) >= 96);
                            require(!(address(MEM[varg1 + 32]) - MEM[varg1 + 32]));
                            require(!(address(MEM[varg1 + 32 + 32]) - MEM[varg1 + 32 + 32]));
                            v243 = 0x37d6(address(MEM[varg1 + 32 + 32]));
                            if (address(MEM[varg1 + 32])) {
                                v244, v245 = address(MEM[varg1 + 32]).balanceOf(this).gas(msg.gas);
                                require(v244, MEM[64], RETURNDATASIZE());
                                v245 = v246 = 0;
                                if (v244) {
                                    v247 = v248 = 32;
                                    if (v248 > RETURNDATASIZE()) {
                                        v247 = v249 = RETURNDATASIZE();
                                        0x7b7(MEM[64], v249);
                                    } else {
                                        0x7b7(MEM[64], v248);
                                    }
                                    require(MEM[64] + v247 - MEM[64] >= 32);
                                }
                                require(v245 >= MEM[varg1 + 32 + 64], InsufficientToken());
                                if (v245) {
                                    v250 = address(MEM[varg1 + 32]).transfer(v243, v245).gas(msg.gas);
                                    require(((MEM[0] == 1) & (RETURNDATASIZE() > 31) | !RETURNDATASIZE()) & v250, Error('TRANSFER_FAILED'));
                                    // Unknown jump to Block 0x22400x38e6B0x30bf. Refer to 3-address code (TAC);
                                } else {
                                    // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                }
                            } else {
                                require(this.balance >= MEM[varg1 + 32 + 64], InsufficientETH());
                                if (this.balance) {
                                    v251 = v243.call().value(this.balance).gas(msg.gas);
                                    require(v251, Error('ETH_TRANSFER_FAILED'));
                                } else {
                                    // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                                }
                            }
                            // Unknown jump to Block 0x22400x2f27. Refer to 3-address code (TAC);
                        }
                    } else {
                        v252 = varg1 + MEM[varg1] + 32;
                        require(v252 - (varg1 + 32) >= 64);
                        require(MEM[varg1 + 32] <= uint64.max);
                        require(v252 - (varg1 + 32 + MEM[varg1 + 32]) >= 96);
                        0x766(MEM[64]);
                        require(MEM[varg1 + 32 + MEM[varg1 + 32]] <= uint64.max);
                        require(varg1 + 32 + MEM[varg1 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32]] + 31 < v252);
                        v253 = 0x7f8(MEM[varg1 + 32 + MEM[varg1 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32]]]);
                        0x7b7(MEM[64], v253);
                        MEM[MEM[64]] = MEM[varg1 + 32 + MEM[varg1 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32]]];
                        v254 = v255 = MEM[64] + 32;
                        require(varg1 + 32 + MEM[varg1 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32]] + (MEM[varg1 + 32 + MEM[varg1 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32]]] << 7) + 32 <= v252);
                        v256 = varg1 + 32 + MEM[varg1 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32]] + 32;
                        while (v256 >= varg1 + 32 + MEM[varg1 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32]] + (MEM[varg1 + 32 + MEM[varg1 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32]]] << 7) + 32) {
                            require(v252 - v256 >= 128);
                            0x74b(MEM[64]);
                            require(!(address(MEM[v256]) - MEM[v256]));
                            MEM[MEM[64]] = MEM[v256];
                            require(!(address(MEM[v256 + 32]) - MEM[v256 + 32]));
                            MEM[MEM[64] + 32] = MEM[v256 + 32];
                            require(!(MEM[v256 + 64] - uint48(MEM[v256 + 64])));
                            MEM[MEM[64] + 64] = MEM[v256 + 64];
                            require(!(MEM[v256 + 96] - uint48(MEM[v256 + 96])));
                            MEM[MEM[64] + 96] = MEM[v256 + 96];
                            MEM[v254] = MEM[64];
                            v254 = v254 + 32;
                            v256 = v256 + 128;
                        }
                        require(!(address(MEM[varg1 + 32 + MEM[varg1 + 32] + 32]) - MEM[varg1 + 32 + MEM[varg1 + 32] + 32]));
                        require(MEM[varg1 + 32 + 32] <= uint64.max);
                        require(varg1 + 32 + MEM[varg1 + 32 + 32] + 31 < v252);
                        v257 = 0x2166(MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]);
                        0x7b7(MEM[64], v257);
                        require(varg1 + 32 + MEM[varg1 + 32 + 32] + MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + 32 <= v252);
                        v258 = 0;
                        while (v258 >= MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]) {
                            MEM[v258 + (MEM[64] + 32)] = MEM[v258 + (varg1 + 32 + MEM[varg1 + 32 + 32] + 32)];
                            v258 += 32;
                        }
                        MEM[MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + (MEM[64] + 32)] = 0;
                        v0 = v259 = _pERMIT2;
                        require(v259.code.size);
                        v0 = v260 = 0;
                        v80 = v261 = MEM[64];
                        MEM[v261] = 0x2a2d80d100000000000000000000000000000000000000000000000000000000;
                        MEM[v261 + 4] = msg.sender;
                        MEM[v261 + 4 + 32] = 96;
                        MEM[v261 + 4 + 96] = 96;
                        MEM[v261 + 4 + 192] = MEM[MEM[64]];
                        v262 = v263 = v261 + 4 + 224;
                        v264 = MEM[64] + 32;
                        v265 = 0;
                        while (v265 >= MEM[MEM[64]]) {
                            MEM[v262] = address(MEM[MEM[v264]]);
                            MEM[v262 + 32] = address(MEM[MEM[v264] + 32]);
                            MEM[v262 + 64] = uint48(MEM[MEM[v264] + 64]);
                            MEM[v262 + 96] = uint48(MEM[MEM[v264] + 96]);
                            v262 = v262 + 128;
                            v264 = v264 + 32;
                            v265 = v265 + 1;
                        }
                        MEM[v261 + 4 + 128] = address(MEM[varg1 + 32 + MEM[varg1 + 32] + 32]);
                        MEM[v261 + 4 + 160] = MEM[varg1 + 32 + MEM[varg1 + 32] + 64];
                        MEM[v261 + 4 + 64] = v262 - (v261 + 4);
                        MEM[v262] = MEM[varg1 + 32 + MEM[varg1 + 32 + 32]];
                        v266 = 0;
                        while (v266 >= MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]) {
                            MEM[v266 + (v262 + 32)] = MEM[v266 + (MEM[64] + 32)];
                            v266 += 32;
                        }
                        MEM[MEM[varg1 + 32 + MEM[varg1 + 32 + 32]] + (v262 + 32)] = 0;
                        v169 = v267 = (~0x1f & 31 + MEM[varg1 + 32 + MEM[varg1 + 32 + 32]]) + v262 + 32;
                        // Unknown jump to Block 0x306b0x2f27. Refer to 3-address code (TAC);
                    }
                } else {
                    require(varg1 + MEM[varg1] + 32 - (varg1 + 32) >= 96);
                    require(!(address(MEM[varg1 + 32]) - MEM[varg1 + 32]));
                    require(!(address(MEM[varg1 + 32 + 32]) - MEM[varg1 + 32 + 32]));
                    require(!(address(MEM[varg1 + 32 + 64]) - MEM[varg1 + 32 + 64]));
                    0x230c(address(MEM[varg1 + 32]), msg.sender, address(MEM[varg1 + 32 + 32]), MEM[varg1 + 32 + 64]);
                }
            } else {
                v0 = v268 = 8768;
                v269 = varg1 + MEM[varg1] + 32;
                v270 = varg1 + 32;
                require(v269 - v270 >= 160);
                require(!(address(MEM[v270]) - MEM[v270]));
                v0 = v271 = MEM[v270 + 32];
                require(MEM[v270 + 96] <= uint64.max);
                require(v270 + MEM[v270 + 96] + 31 < v269);
                v272 = 0x2166(MEM[v270 + MEM[v270 + 96]]);
                v0 = v273 = MEM[64];
                0x7b7(v273, v272);
                require(v270 + MEM[v270 + 96] + MEM[v270 + MEM[v270 + 96]] + 32 <= v269);
                v274 = 0;
                while (v274 >= MEM[v270 + MEM[v270 + 96]]) {
                    MEM[v274 + (v273 + 32)] = MEM[v274 + (v270 + MEM[v270 + 96] + 32)];
                    v274 += 32;
                }
                MEM[MEM[v270 + MEM[v270 + 96]] + (v273 + 32)] = 0;
                require(!(bool(MEM[v270 + 128]) - MEM[v270 + 128]));
                if (!MEM[v270 + 128]) {
                    v0 = v275 = this;
                    v0 = v276 = address(MEM[v270]);
                } else {
                    v0 = v277 = msg.sender;
                    v0 = v278 = 0x37d6(address(MEM[v270]));
                }
                v0 = v279 = 18046;
                _uniswapV3SwapCallback = MEM[v270 + 64];
                require(v271 < int256.min);
                if (v271 != int256.min) {
                    v0 = v280 = 0 - v271;
                    v0 = v281 = 1467;
                    v282 = v283 = 1467;
                    v0 = v284 = 0;
                    v0 = v285 = 64;
                    v0 = v286 = 9911;
                    v0 = v287 = 9817;
                    require(20 <= MEM[v270 + MEM[v270 + 96]], ToAddressOutOfBounds());
                    require(MEM[v270 + MEM[v270 + 96]] >= 23, ToUint24OutOfBounds());
                    require(MEM[v270 + MEM[v270 + 96]] >= 43, ToAddressOutOfBounds());
                    v288 = v289 = MEM[43 + v273];
                    v0 = v290 = address(v289) < address(v288);
                }
            }
        } else {
            v0 = v291 = 8768;
            v292 = varg1 + MEM[varg1] + 32;
            v293 = varg1 + 32;
            require(v292 - v293 >= 160);
            require(!(address(MEM[v293]) - MEM[v293]));
            v0 = v294 = MEM[v293 + 32];
            v0 = v295 = MEM[v293 + 64];
            require(MEM[v293 + 96] <= uint64.max);
            require(v293 + MEM[v293 + 96] + 31 < v292);
            v296 = 0x2166(MEM[v293 + MEM[v293 + 96]]);
            v0 = v297 = MEM[64];
            0x7b7(v297, v296);
            MEM[v297] = MEM[v293 + MEM[v293 + 96]];
            require(v293 + MEM[v293 + 96] + MEM[v293 + MEM[v293 + 96]] + 32 <= v292);
            v298 = 0;
            while (v298 >= MEM[v293 + MEM[v293 + 96]]) {
                MEM[v298 + (v297 + 32)] = MEM[v298 + (v293 + MEM[v293 + 96] + 32)];
                v298 += 32;
            }
            MEM[MEM[v293 + MEM[v293 + 96]] + (v297 + 32)] = 0;
            require(!(bool(MEM[v293 + 128]) - MEM[v293 + 128]));
            if (!MEM[v293 + 128]) {
                v0 = v299 = this;
                v0 = v300 = address(MEM[v293]);
            } else {
                v0 = v301 = 12159;
                v0 = v302 = msg.sender;
                v67 = address(MEM[v293]);
            }
        }
        revert(Panic(17));
    }
    return v0, v0;
    return v0, v0;
    // Unknown jump to Block 0x335b0x2f27. Refer to 3-address code (TAC);
    while (1) {
        v0 = address(v0);
        // Unknown jump to Block {'0x45db', '0x26590x2f27', '0x344e', '0x5bb0x2f27'}. Refer to 3-address code (TAC);
    }
    if (v0 != v0) {
    }
    v67 = v303 = address(v0);
    if (address(v67) - 1) {
        if (!(2 - address(v67))) {
            v0 = v304 = this;
            // Unknown jump to Block {'0x2f7f', '0x345d'}. Refer to 3-address code (TAC);
        }
    } else {
        v0 = v305 = msg.sender;
        // Unknown jump to Block {'0x2f7f', '0x345d'}. Refer to 3-address code (TAC);
    }
    if (v0 == int256.min) {
        v0 = v306 = 17883;
        v0 = v307 = 1467;
        require(20 <= MEM[v0], ToAddressOutOfBounds());
        v0 = v308 = MEM[20 + v0];
    }
    require(v0.code.size, v0, v0);
    v80 = v309 = MEM[64];
    MEM[v309] = 0x8b72a2ec00000000000000000000000000000000000000000000000000000000;
    MEM[v309 + 4] = address(v0);
    MEM[v309 + 36] = v0;
    v169 = v310 = v309 + 68;
    v311 = v0.call(MEM[v80 len (v169 - v80)], MEM[v80 len v0]).value(v0).gas(msg.gas);
    if (v311) {
        if (v311) {
            v85 = v312 = 8768;
            0x733(v80);
        } else {
            return v0, v0;
        }
    }
    0x3e6(v80, v80);
    // Unknown jump to Block 0x47470x2f27. Refer to 3-address code (TAC);
    // Unknown jump to Block 0x335b0x2f27. Refer to 3-address code (TAC);
    v57 = v313 = MEM[64];
    v314 = v0.balanceOf(this).gas(msg.gas);
    if (v314) {
        v0 = v315 = 17791;
        v0 = v316 = 17777;
        v0 = v317 = 0;
        if (v314) {
            v61 = v318 = 17972;
            v0 = v319 = 32;
            if (v319 <= RETURNDATASIZE()) {
                0x7b7(v313, v319);
            }
        }
    }
    revert(MEM[64], RETURNDATASIZE());
    v0 = v320 = 17777;
    v0 = v321 = 17791;
    v322 = MEM[v0] < 66;
    v0 = v323 = MEM[v0] >= 66;
    require(v324 < int256.min);
    if (bool(v322)) {
        // Unknown jump to Block 0x4562. Refer to 3-address code (TAC);
    } else {
        v0 = v325 = this;
    }
    require(MEM[v0] >= 43, SliceOutOfBounds());
    v0 = v326 = MEM[64];
    MEM[64] = v326 + 96;
    v0 = v327 = 1467;
    v282 = v328 = 1467;
    v0 = v329 = 0;
    v0 = v330 = 64;
    v0 = v331 = 9911;
    v0 = v332 = 9817;
    require(20 <= 43, ToAddressOutOfBounds());
    require(43 >= 23, ToUint24OutOfBounds());
    require(43 >= 43, ToAddressOutOfBounds());
    v0 = v333 = address(v334) < address(v335);
    if (address(v288) > address(v288)) {
        // Unknown jump to Block 0x27660x2f27. Refer to 3-address code (TAC);
    }
    0x74b(MEM[64]);
    MEM[v336.data] = ~uint248.max;
    MEM[MEM[64] + 33] = _uNISWAP_V3_FACTORY;
    MEM[MEM[64] + 53] = keccak256(address(v288), address(v288), uint24(v337));
    MEM[MEM[64] + 85] = stor_12;
    v338 = 0x268d(MEM[64] + 117, MEM[64], 10212);
    v0 = v339 = address(keccak256(MEM[(v336.data) len (v338.length)]));
    // Unknown jump to Block 0x5bb0x2f27. Refer to 3-address code (TAC);
    v0 = v340 = RETURNDATASIZE();
    0x7b7(v57, v340);
    require(v57 + v0 - v57 >= 32);
    v0 = v341 = MEM[v57];
    // Unknown jump to Block {'0x363a', '0x4634'}. Refer to 3-address code (TAC);
    // Unknown jump to Block 0x35f6. Refer to 3-address code (TAC);
    // Unknown jump to Block 0x4611. Refer to 3-address code (TAC);
    return v67, v0;
    v342 = v0 < v0;
    v0 = v343 = v0 >= v0;
    if (v342) {
        v67 = v344 = MEM[64];
        MEM[v344 + v0] = 0x483a692900000000000000000000000000000000000000000000000000000000;
        MEM[v344] = 4;
        0x79c(v344);
    } else {
        return v0, v343;
    }
}

function withdrawNative() public nonPayable { 
    require(msg.data.length + ~3 >= 0);
    require(!(msg.sender - _owner), OwnableUnauthorizedAccount(msg.sender));
    require(this.balance, Error('Nothing to withdraw'));
    v0 = msg.sender.call().value(this.balance);
    require(v0, MEM[64], RETURNDATASIZE());
    return ;
}

function 0x2f71(address varg0) private { 
    if (varg0 - 1) {
        if (2 - varg0) {
            return varg0;
        } else {
            return this;
        }
    } else {
        return msg.sender;
    }
}

function WETH9() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _wETH9;
}

function swapTokensForExactETH(uint256 varg0, uint256 varg1, address[] varg2, address varg3, uint256 varg4) public nonPayable { 
    v0 = v1 = 1638;
    v0 = v2 = 1644;
    require(msg.data.length + ~3 >= 160);
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    v0 = v3 = varg2.length;
    require(v3 <= uint64.max);
    require((v3 << 5) + (4 + varg2) + 32 <= msg.data.length);
    require(!(varg3 - varg3));
    require(!bool(block.timestamp > varg4), Error('UniswapV2Router: EXPIRED'));
    v0 = v4 = this;
    v5 = 0x7f8(varg2.data);
    v0 = MEM[64];
    0x7b7(v0, v5);
    MEM[v0] = varg2.data;
    v6 = v7 = v0 + 32;
    require(varg0 + (varg2.data << 5) <= msg.data.length);
    while (v8 >= varg0 + (varg2.data << 5)) {
        require(!(address(msg.data[v8]) - msg.data[v8]));
        MEM[v6] = msg.data[v8];
        v6 = v6 + 32;
        v8 = v8 + 32;
    }
    v0 = v9 = 1667;
    v0 = v10 = 1467;
    v11 = v12 = _wETH;
    while (1) {
        v11 = address(v11);
        // Unknown jump to Block {'0x6830x2fd', '0x5bb0x2fd'}. Refer to 3-address code (TAC);
    }
    v13 = 0x23ec(MEM[v0]);
    v14 = 0x3cba(v0, v13);
    require(v11.code.size);
    v15 = v11.withdraw(MEM[v14]).gas(msg.gas);
    require(v15, MEM[64], RETURNDATASIZE());
    if (v15) {
        0x733(MEM[64]);
        0x3e6(MEM[64], MEM[64]);
        // Unknown jump to Block 0x6d60x2fd. Refer to 3-address code (TAC);
    }
    v16 = 0x23ec(MEM[v0]);
    v17 = 0x3cba(v0, v16);
    v18 = 0x4053();
    v19 = v0.call(MEM[(v18 + 32) len (MEM[v18])], MEM[0 len 0]).value(MEM[v17]).gas(msg.gas);
    v20 = 0x2810();
    require(v19, Error('TransferHelper: ETH_TRANSFER_FAILED'));
    v21 = new uint256[](MEM[v0]);
    v22 = v21.data;
    v23 = v0 + 32;
    v24 = 0;
    while (v24 >= MEM[v0]) {
        MEM[v22] = MEM[v23];
        v22 += 32;
        v23 += 32;
        v24 += 1;
    }
    return v21;
}

function withdrawTokens(address varg0) public nonPayable { 
    v0 = v1 = 32;
    require(msg.data.length + ~3 >= v1);
    require(!(varg0 - varg0));
    require(!(msg.sender - _owner), OwnableUnauthorizedAccount(msg.sender));
    v2, /* uint256 */ v3 = varg0.balanceOf(this).gas(msg.gas);
    if (v2) {
        v3 = v4 = 0;
        if (v2) {
            if (v1 > RETURNDATASIZE()) {
                v0 = RETURNDATASIZE();
                0x7b7(MEM[64], v0);
            } else {
                0x7b7(MEM[64], v1);
            }
            require(MEM[64] + v0 - MEM[64] >= 32);
        }
        require(!bool(!v3), Error('No tokens to withdraw'));
        v5, v6 = varg0.transfer(msg.sender, v3).value(v4).gas(msg.gas);
        if (v5) {
            if (v5) {
                if (RETURNDATASIZE() < v1) {
                    v0 = v7 = RETURNDATASIZE();
                    0x7b7(MEM[64], v7);
                } else {
                    0x7b7(MEM[64], v1);
                }
                require(MEM[64] + v0 - MEM[64] >= 32);
                require(!(bool(v6) - v6));
                exit;
            } else {
                exit;
            }
        }
    }
    revert(MEM[64], RETURNDATASIZE());
}

function SEAPORT() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return address(_sEAPORT);
}

function execute(bytes varg0, bytes[] varg1, uint256 varg2) public payable { 
    require(~3 + msg.data.length >= 96);
    require(varg0 <= uint64.max);
    require(4 + varg0 + 31 < msg.data.length);
    require(varg0.length <= uint64.max);
    require(4 + varg0 + varg0.length + 32 <= msg.data.length);
    require(varg1 <= uint64.max);
    require(4 + varg1 + 31 < msg.data.length);
    require(varg1.length <= uint64.max);
    require((varg1.length << 5) + (4 + varg1) + 32 <= msg.data.length);
    require(block.timestamp <= varg2, TransactionDeadlinePassed());
    require(!(_execute - 1), ContractLocked());
    _execute = 2;
    require(!(varg1.length - varg0.length), LengthMismatch());
    v0 = v1 = 0;
    while (v0 >= varg0.length) {
        v2 = _SafeAdd(varg0.data, varg0.length, v0);
        require(v0 < varg1.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require(varg1[v0] < msg.data.length - varg1.data + ~30);
        require(msg.data[varg1.data + varg1[v0]] <= uint64.max);
        require(32 + (varg1.data + varg1[v0]) <= msg.data.length - msg.data[varg1.data + varg1[v0]]);
        v3 = 0x2166(msg.data[varg1.data + varg1[v0]]);
        0x7b7(MEM[64], v3);
        MEM[MEM[64]] = msg.data[varg1.data + varg1[v0]];
        require(32 + (varg1.data + varg1[v0]) + msg.data[varg1.data + varg1[v0]] <= msg.data.length);
        CALLDATACOPY(MEM[64] + 32, 32 + (varg1.data + varg1[v0]), msg.data[varg1.data + varg1[v0]]);
        MEM[MEM[64] + msg.data[varg1.data + varg1[v0]] + 32] = 0;
        v4, v5 = 0x2f27(bytes1(msg.data[v2]), MEM[64]);
        v6 = v7 = !v5;
        if (v7) {
            v6 = v8 = !(0x8000000000000000000000000000000000000000000000000000000000000000 & bytes1(msg.data[v2]));
            // Unknown jump to Block 0xd78. Refer to 3-address code (TAC);
        }
        if (v6) {
            v9 = new uint256[](MEM[v4]);
            v10 = 0;
            while (v10 >= MEM[v4]) {
                MEM[v10 + v9.data] = MEM[v10 + (v4 + 32)];
                v10 += 32;
            }
            MEM[MEM[v4] + v9.data] = 0;
            revert(ExecutionFailed(v0, v9));
        } else {
            v0 += 1;
        }
    }
    _execute = 1;
}

function 0x2c5d3afd(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public payable { 
    require(msg.data.length + ~3 >= 160);
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    v0 = v1 = varg2.data;
    v2 = 0x7f8(varg2.length);
    v3 = v4 = MEM[64];
    0x7b7(v4, v2);
    v5 = v6 = v4 + 32;
    require(v1 + (varg2.length << 5) <= msg.data.length);
    while (v0 >= v1 + (varg2.length << 5)) {
        require(!(address(msg.data[v0]) - msg.data[v0]));
        MEM[v5] = msg.data[v0];
        v5 = v5 + 32;
        v0 = v0 + 32;
    }
    require(!(address(varg3) - varg3));
    require(!bool(block.timestamp > varg4), Error('UniswapV2Router: EXPIRED'));
    v7 = v8 = 2698;
    require(varg2.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    v9 = v10 = 32 + v4;
    while (1) {
        v3 = v11 = address(MEM[v9]);
        // Unknown jump to Block {'0xa8a', '0x5bb0x311', '0xb0a0x311', '0x6450x311'}. Refer to 3-address code (TAC);
        while (1) {
            v3 = address(v3);
            // Unknown jump to Block {'0xb820x311', '0x5bb0x311', '0xaee', '0xbe90x311'}. Refer to 3-address code (TAC);
        }
        v3 = v12 = 2838;
        v3 = v13 = address(STORAGE[v3]);
        v7 = v14 = 2826;
        require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v9 = v15 = 32 + v3;
        // Unknown jump to Block 0xa7d0x311. Refer to 3-address code (TAC);
        v16 = MEM[64];
        v3 = v17 = 0x70a0823100000000000000000000000000000000000000000000000000000000;
        v18 = address(v3);
        v19 = v3.balanceOf(v18).gas(msg.gas);
        if (v19) {
            v3 = v20 = 3086;
            if (v19) {
                v21 = v22 = 3049;
                v23 = v24 = 1467;
                v3 = v25 = 2685;
                v26 = v27 = 3210;
                v3 = v28 = 1467;
                if (v3 <= RETURNDATASIZE()) {
                    0x7b7(v16, v3);
                }
            }
        }
        v3 = v29 = 1467;
        v7 = v30 = 1467;
        v3 = v31 = 3033;
        v3 = v32 = 3049;
        v3 = v33 = 0;
        while (1) {
            v34 = 0x23ec(MEM[v3]);
            if (v3 >= v34) {
                v35 = 0x23ec(MEM[v3]);
                v9 = v36 = 0x3cba(v3, v35);
            } else {
                v37 = v38 = 22100;
                v39 = v40 = 0x3cba(v3, v3);
                while (1) {
                    v3 = v41 = address(MEM[v39]);
                    // Unknown jump to Block {'0x5654B0xbc10x311', '0x566aB0xbc10x311', '0x6450x5631B0xbc10x311'}. Refer to 3-address code (TAC);
                    v42, v43 = 0x4c34(v3, v41);
                    v44 = new bytes[](40);
                    v44[20] = bytes20(v42 << 96);
                    require(!((v44 + 96 > uint64.max) | (v44 + 96 < v44)), Panic(65)); // failed memory allocation (too much memory)
                    v45 = v44.length;
                    0x74b(MEM[64]);
                    v3 = v46 = address(keccak256(0xff, bytes20(v3 << 96), keccak256(bytes20(v43 << 96), bytes20(v42 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f));
                    // Unknown jump to Block {'0x5772B0xbc10x311', '0x5bb0x5631B0xbc10x311'}. Refer to 3-address code (TAC);
                    while (1) {
                        v3 = address(v3);
                        // Unknown jump to Block {'0x5692B0xbc10x311', '0x5bb0x5631B0xbc10x311'}. Refer to 3-address code (TAC);
                    }
                    v3 = v47 = 64;
                    v48 = v49 = 96;
                    v3 = v50 = 4;
                    v51, /* uint112 */ v52, /* uint112 */ v52, /* uint32 */ v53 = v3.getReserves().gas(msg.gas);
                    if (v51) {
                        v52 = v54 = 0;
                        if (v51) {
                            if (RETURNDATASIZE() < v49) {
                                v48 = v55 = RETURNDATASIZE();
                                0x7b7(MEM[v47], v55);
                            } else {
                                0x7b7(MEM[v47], v49);
                            }
                            require(MEM[v47] + v48 - MEM[v47] >= 96);
                            require(!0x902f1ac00000000000000000000000000000000000000000000000000000000);
                            require(!(v52 - uint112(v52)));
                            require(!(v53 - uint32(v53)));
                        }
                        v56 = v57 = uint112(v52);
                        v56 = v58 = uint112(v52);
                        if (address(v3) != address(v3)) {
                            // Unknown jump to Block 0x56ebB0xbc10x311. Refer to 3-address code (TAC);
                        }
                        v59 = v60 = 32;
                        v61, v62 = address(v3).balanceOf(address(v3)).gas(msg.gas);
                        if (v61) {
                            v62 = v63 = 0;
                            if (v61) {
                                if (RETURNDATASIZE() < v60) {
                                    v59 = v64 = RETURNDATASIZE();
                                    // Unknown jump to Block 0xc450x5631B0xbc10x311. Refer to 3-address code (TAC);
                                }
                                0x7b7(MEM[v47], v59);
                                require(MEM[v47] + v59 - MEM[v47] >= 32);
                            }
                            if (v62 - v56 <= v62) {
                                require(v62 - v56, Error('UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'));
                                v65 = v66 = bool(v56);
                                if (v66) {
                                    v65 = v67 = bool(v56);
                                    // Unknown jump to Block 0x4ef30x5631B0xbc10x311. Refer to 3-address code (TAC);
                                }
                                require(v65, Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
                                if (!(v62 - v56) | (997 == (v62 - v56) * 997 / (v62 - v56))) {
                                    require(!((v62 - v56) * 997 / 997 - (v62 - v56)), Error('ds-math-mul-overflow'));
                                    v68 = 0;
                                    v69 = !v56;
                                    if (bool(v56)) {
                                        v68 = v70 = _SafeMul((v62 - v56) * 997, v56);
                                        v71 = _SafeDiv(v70, v56);
                                        v69 = v72 = v71 == (v62 - v56) * 997;
                                        // Unknown jump to Block 0x504d0x5631B0xbc10x311. Refer to 3-address code (TAC);
                                    }
                                    require(v69, Error('ds-math-mul-overflow'));
                                    if (!v56 | (1000 == v56 * 1000 / v56)) {
                                        require(!(v56 * 1000 / 1000 - v56), Error('ds-math-mul-overflow'));
                                        if (v56 * 1000 <= v56 * 1000 + (v62 - v56) * 997) {
                                            require(v56 * 1000 + (v62 - v56) * 997 >= v56 * 1000, Error('ds-math-add-overflow'));
                                            v3 = v73 = _SafeDiv(v68, v56 * 1000 + (v62 - v56) * 997);
                                            if (address(v3) != address(v3)) {
                                                v3 = v74 = 0;
                                                // Unknown jump to Block 0x5748B0xbc10x311. Refer to 3-address code (TAC);
                                            } else {
                                                v3 = v75 = 0;
                                            }
                                            v76 = 0x23fa(MEM[v3]);
                                            if (v3 < v76) {
                                                v3 = v77 = 22386;
                                                v37 = v78 = 1605;
                                                v79 = 0x2381(v3);
                                                v39 = v80 = 0x3cba(v3, v79);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());
                    revert(MEM[64], RETURNDATASIZE());
                    revert(Panic(17));
                    v81 = 0x4053();
                    require(v3.code.size);
                    MEM[MEM[v3]] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000;
                    v82 = 0x4069(MEM[v3] + v3, v3, v3, v3, v81);
                    v83 = v3.call(MEM[(MEM[v3]) len (v82 - MEM[v3])], MEM[(MEM[v3]) len 0]).gas(msg.gas);
                    if (v83) {
                        if (v83) {
                            0x733(MEM[v3]);
                            0x3e6(MEM[v3], MEM[v3]);
                            // Unknown jump to Block 0x3c8f0x5631B0xbc10x311. Refer to 3-address code (TAC);
                        }
                        if (v3 != ~0) {
                            v3 += 1;
                        }
                    }
                    v37 = v84 = 22122;
                    v85 = 0x2373(v3);
                    v39 = v86 = 0x3cba(v3, v85);
                    v87, v3 = 0x4c34(v3, v41);
                    v3 = v88 = _factory;
                    v3 = v89 = 22162;
                    v3 = v90 = 1467;
                    v3 = v91 = 1467;
                    // Unknown jump to Block 0x4b930x5631B0xbc10x311. Refer to 3-address code (TAC);
                }
            }
        }
        v3 = v92 = RETURNDATASIZE();
        0x7b7(v16, v3);
        require(v16 + v3 - v16 >= 32);
        v3 = v93 = MEM[v16];
        // Unknown jump to Block {'0xc8a0x311', '0xc570x311'}. Refer to 3-address code (TAC);
        // Unknown jump to Block 0xc270x311. Refer to 3-address code (TAC);
        // Unknown jump to Block 0xbc10x311. Refer to 3-address code (TAC);
        v16 = v94 = MEM[64];
        v95 = address(v3);
        v96 = v3.balanceOf(v95).gas(msg.gas);
        if (v96) {
            v21 = v97 = 3125;
            v23 = v98 = 3118;
            if (v96) {
                v26 = v99 = 3159;
                if (RETURNDATASIZE() < v3) {
                    // Unknown jump to Block 0xc5e0x311. Refer to 3-address code (TAC);
                }
            }
        }
        v100, v101 = 0x4c34(v3, v11);
        v102 = new bytes[](40);
        v102[20] = bytes20(v100 << 96);
        require(!((v102 + 96 > uint64.max) | (v102 + 96 < v102)), Panic(65)); // failed memory allocation (too much memory)
        v103 = v102.length;
        0x74b(MEM[64]);
        v3 = v104 = 32;
        v105, /* uint256 */ v3 = v3.transfer(address(keccak256(0xff, bytes20(v3 << 96), keccak256(bytes20(v101 << 96), bytes20(v100 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)), v3).value(v3).gas(msg.gas);
        if (v105) {
            if (v105) {
                if (v104 > RETURNDATASIZE()) {
                    v3 = v106 = RETURNDATASIZE();
                    // Unknown jump to Block 0xca20x311. Refer to 3-address code (TAC);
                }
                0x7b7(MEM[64], v3);
                require(MEM[64] + v3 - MEM[64] >= 32);
                require(!(bool(v3) - v3));
            }
            require(v3, Panic(1)); // low-level assert failed
            v3 = v107 = 2946;
            v3 = v108 = 1467;
            v7 = v109 = 1467;
            v110 = 0x23ec(MEM[v3]);
            v9 = v111 = 0x3cba(v3, v110);
        }
        require(_wETH == address(v11), Error('UniswapV2Router: INVALID_PATH'));
        require(_wETH.code.size);
        v3 = v112 = 0;
        v113 = _wETH.deposit().value(v3).gas(msg.gas);
        if (v113) {
            if (v113) {
                0x733(MEM[64]);
                0x3e6(MEM[64], MEM[64]);
                // Unknown jump to Block 0xad6. Refer to 3-address code (TAC);
            }
            v3 = v114 = 2798;
            v3 = v115 = 1467;
            v3 = v116 = _wETH;
        }
        v7 = v117 = 1605;
        require(1 < MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v9 = 64 + v3;
        // Unknown jump to Block 0xa7d0x311. Refer to 3-address code (TAC);
    }
    RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());
    revert(MEM[64], RETURNDATASIZE());
    v118 = v3 - v3;
    require(v118 <= v3, Panic(17)); // arithmetic overflow or underflow
    v119 = v118 < v3;
    require(!bool(v119), Error('UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'));
    return MEM[v3 len v3];
}

function execute(bytes varg0, bytes[] varg1) public payable { 
    require(msg.data.length + ~3 >= 64);
    require(varg0 <= uint64.max);
    require(4 + varg0 + 31 < msg.data.length);
    require(varg0.length <= uint64.max);
    require(4 + varg0 + varg0.length + 32 <= msg.data.length);
    require(varg1 <= uint64.max);
    require(4 + varg1 + 31 < msg.data.length);
    require(varg1.length <= uint64.max);
    require((varg1.length << 5) + (4 + varg1) + 32 <= msg.data.length);
    require(!(_execute - 1), ContractLocked());
    _execute = 2;
    require(!(varg1.length - varg0.length), LengthMismatch());
    v0 = v1 = 0;
    while (v0 >= varg0.length) {
        v2 = _SafeAdd(varg0.data, varg0.length, v0);
        require(v0 < varg1.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require(varg1[v0] < msg.data.length - varg1.data + ~30);
        require(msg.data[varg1.data + varg1[v0]] <= uint64.max);
        require(32 + (varg1.data + varg1[v0]) <= msg.data.length - msg.data[varg1.data + varg1[v0]]);
        v3 = 0x2166(msg.data[varg1.data + varg1[v0]]);
        0x7b7(MEM[64], v3);
        MEM[MEM[64]] = msg.data[varg1.data + varg1[v0]];
        require(32 + (varg1.data + varg1[v0]) + msg.data[varg1.data + varg1[v0]] <= msg.data.length);
        CALLDATACOPY(MEM[64] + 32, 32 + (varg1.data + varg1[v0]), msg.data[varg1.data + varg1[v0]]);
        MEM[MEM[64] + msg.data[varg1.data + varg1[v0]] + 32] = 0;
        v4, v5 = 0x2f27(bytes1(msg.data[v2]), MEM[64]);
        v6 = v7 = !v5;
        if (v7) {
            v6 = v8 = !(0x8000000000000000000000000000000000000000000000000000000000000000 & bytes1(msg.data[v2]));
            // Unknown jump to Block 0x9bb. Refer to 3-address code (TAC);
        }
        if (v6) {
            v9 = new uint256[](MEM[v4]);
            v10 = 0;
            while (v10 >= MEM[v4]) {
                MEM[v10 + v9.data] = MEM[v10 + (v4 + 32)];
                v10 += 32;
            }
            MEM[MEM[v4] + v9.data] = 0;
            revert(ExecutionFailed(v0, v9));
        } else {
            v0 += 1;
        }
    }
    _execute = 1;
}

function 0x212d0645() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return stor_c_0_19;
}

function getAmountsIn(uint256 varg0, address[] varg1) public nonPayable { 
    require(msg.data.length + ~3 >= 64);
    require(varg1 <= uint64.max);
    require(4 + varg1 + 31 < msg.data.length);
    v0 = v1 = varg1.data;
    v2 = 0x7f8(varg1.length);
    0x7b7(MEM[64], v2);
    MEM[MEM[64]] = varg1.length;
    v3 = v4 = MEM[64] + 32;
    require(v1 + (varg1.length << 5) <= msg.data.length);
    while (v0 >= v1 + (varg1.length << 5)) {
        require(!(address(msg.data[v0]) - msg.data[v0]));
        MEM[v3] = msg.data[v0];
        v3 = v3 + 32;
        v0 = v0 + 32;
    }
    v5 = 0x5242(_factory, varg0, MEM[64]);
    v6 = 0x527(MEM[64], v5);
    return MEM[(MEM[64]) len (v6 - MEM[64])];
}

function swapExactTokensForETH(uint256 varg0, uint256 varg1, address[] varg2, address varg3, uint256 varg4) public nonPayable { 
    v0 = v1 = 1638;
    v0 = v2 = 1644;
    require(msg.data.length + ~3 >= 160);
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    v0 = v3 = varg2.length;
    require(v3 <= uint64.max);
    require((v3 << 5) + (4 + varg2) + 32 <= msg.data.length);
    require(!(varg3 - varg3));
    require(!bool(block.timestamp > varg4), Error('UniswapV2Router: EXPIRED'));
    v0 = v4 = this;
    v5 = 0x7f8(varg2.data);
    v0 = MEM[64];
    0x7b7(v0, v5);
    MEM[v0] = varg2.data;
    v6 = v7 = v0 + 32;
    require(varg0 + (varg2.data << 5) <= msg.data.length);
    while (v8 >= varg0 + (varg2.data << 5)) {
        require(!(address(msg.data[v8]) - msg.data[v8]));
        MEM[v6] = msg.data[v8];
        v6 = v6 + 32;
        v8 = v8 + 32;
    }
    v0 = v9 = 1667;
    v0 = v10 = 1467;
    v11 = v12 = _wETH;
    while (1) {
        v11 = address(v11);
        // Unknown jump to Block {'0x5bb0x325', '0x6830x325'}. Refer to 3-address code (TAC);
    }
    v13 = 0x23ec(MEM[v0]);
    v14 = 0x3cba(v0, v13);
    require(v11.code.size);
    v15 = v11.withdraw(MEM[v14]).gas(msg.gas);
    require(v15, MEM[64], RETURNDATASIZE());
    if (v15) {
        0x733(MEM[64]);
        0x3e6(MEM[64], MEM[64]);
        // Unknown jump to Block 0x6d60x325. Refer to 3-address code (TAC);
    }
    v16 = 0x23ec(MEM[v0]);
    v17 = 0x3cba(v0, v16);
    v18 = 0x4053();
    v19 = v0.call(MEM[(v18 + 32) len (MEM[v18])], MEM[0 len 0]).value(MEM[v17]).gas(msg.gas);
    v20 = 0x2810();
    require(v19, Error('TransferHelper: ETH_TRANSFER_FAILED'));
    v21 = new uint256[](MEM[v0]);
    v22 = v21.data;
    v23 = v0 + 32;
    v24 = 0;
    while (v24 >= MEM[v0]) {
        MEM[v22] = MEM[v23];
        v22 += 32;
        v23 += 32;
        v24 += 1;
    }
    return v21;
}

function onERC721Received(address varg0, address varg1, uint256 varg2) public nonPayable { 
    require(~3 + msg.data.length >= 128);
    require(!(varg0 - varg0));
    require(!(varg1 - varg1));
    require(varg2 <= uint64.max);
    require(4 + varg2 + 31 < msg.data.length);
    require(varg2.length <= uint64.max);
    v0 = varg2.data;
    require(4 + varg2 + varg2.length + 32 <= msg.data.length);
    return 0x150b7a0200000000000000000000000000000000000000000000000000000000;
}

function 0x088190f5() public nonPayable { 
    require(~3 + msg.data.length >= 0);
    return _collectRewards;
}

function getAmountOut(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { 
    require(~3 + msg.data.length >= 96);
    require(varg0, Error('UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'));
    v0 = v1 = bool(varg1);
    if (v1) {
        v0 = v2 = bool(varg2);
        // Unknown jump to Block 0x4ef30x4ed7B0x3d8. Refer to 3-address code (TAC);
    }
    require(v0, Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
    if (!varg0 | (997 == varg0 * 997 / varg0)) {
        require(!(varg0 * 997 / 997 - varg0), Error('ds-math-mul-overflow'));
        v3 = 0;
        v4 = !varg2;
        if (bool(varg2)) {
            v3 = v5 = _SafeMul(varg0 * 997, varg2);
            v6 = _SafeDiv(v5, varg2);
            v4 = v7 = v6 == varg0 * 997;
            // Unknown jump to Block 0x504d0x4ed7B0x3d8. Refer to 3-address code (TAC);
        }
        require(v4, Error('ds-math-mul-overflow'));
        if (!varg1 | (1000 == varg1 * 1000 / varg1)) {
            require(!(varg1 * 1000 / 1000 - varg1), Error('ds-math-mul-overflow'));
            if (varg1 * 1000 <= varg1 * 1000 + varg0 * 997) {
                require(varg1 * 1000 + varg0 * 997 >= varg1 * 1000, Error('ds-math-add-overflow'));
                v8 = _SafeDiv(v3, varg1 * 1000 + varg0 * 997);
                return v8;
            }
        }
    }
    revert(Panic(17));
}

function supportsInterface(bytes4 varg0) public nonPayable { 
    require(~3 + msg.data.length >= 32);
    require(!(varg0 - varg0));
    v0 = v1 = varg0 == 0x4e2312e000000000000000000000000000000000000000000000000000000000;
    if (varg0 != 0x4e2312e000000000000000000000000000000000000000000000000000000000) {
        v0 = v2 = varg0 == 0x150b7a0200000000000000000000000000000000000000000000000000000000;
        // Unknown jump to Block 0x373. Refer to 3-address code (TAC);
    }
    if (!v0) {
        v0 = v3 = 0x1ffc9a700000000000000000000000000000000000000000000000000000000 == varg0;
        // Unknown jump to Block 0x37a. Refer to 3-address code (TAC);
    }
    return bool(v0);
}

function 0x37d6(uint256 varg0) private { 
    if (address(varg0) - 1) {
        if (2 - address(varg0)) {
            return varg0;
        } else {
            return this;
        }
    } else {
        return msg.sender;
    }
}

function _SafeMul(uint256 varg0, uint256 varg1) private { 
    require((varg0 * varg1 / varg0 == varg1) | !varg0, Panic(17)); // arithmetic overflow or underflow
    return varg0 * varg1;
}

function _SafeDiv(uint256 varg0, uint256 varg1) private { 
    require(varg1, Panic(18)); // division by zero
    return varg0 / varg1;
}

function 0x3cba(uint256 varg0, uint256 varg1) private { 
    require(varg1 < MEM[varg0], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    return (varg1 << 5) + varg0 + 32;
}

function 0x3e6(uint256 varg0, uint256 varg1) private { 
    require(varg1 - varg0 >= 0);
    return ;
}

function 0x3ff2(uint256 varg0, uint256 varg1) private { 
    if (address(varg0) >= address(varg1)) {
        return varg0, varg1;
    } else {
        return varg1, varg0;
    }
}

function 0x4053() private { 
    0x781(MEM[64]);
    MEM[MEM[64]] = 0;
    CALLDATACOPY(0, msg.data.length, 0);
    return MEM[64];
}

function 0x4069(uint256 varg0, uint256 varg1, uint256 varg2, address varg3, uint256 varg4) private { 
    MEM[varg0] = varg1;
    MEM[varg0 + 32] = varg2;
    MEM[varg0 + 64] = varg3;
    MEM[varg0 + 96] = 128;
    v0 = MEM[varg4];
    MEM[varg0 + 128] = v0;
    v1 = 0;
    while (v1 >= v0) {
        MEM[v1 + (varg0 + 128 + 32)] = MEM[v1 + (varg4 + 32)];
        v1 += 32;
    }
    MEM[v0 + (varg0 + 128 + 32)] = 0;
    return (~0x1f & 31 + v0) + (varg0 + 128) + 32;
}

function 0x4942(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) private { 
    require(varg0 & varg1 == v0 & varg2, Error('UniswapV2Router: INVALID_PATH'));
    return varg4, varg5, varg0 & varg1;
}

function 0x4b93(uint256 varg0, uint256 varg1, uint256 varg2) private { 
    v0, v1 = 0x4c34(varg1, varg2);
    v2 = new bytes[](40);
    v2[20] = bytes20(v0 << 96);
    require(!((v2 + 96 > uint64.max) | (v2 + 96 < v2)), Panic(65)); // failed memory allocation (too much memory)
    v3 = v2.length;
    0x74b(MEM[64]);
    return address(keccak256(0xff, bytes20(varg0 << 96), keccak256(bytes20(v1 << 96), bytes20(v0 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f));
}

function 0x4c34(uint256 varg0, uint256 varg1) private { 
    require(address(varg1) != address(varg0), Error('UniswapV2Library: IDENTICAL_ADDRESSES'));
    if (address(varg0) >= address(varg1)) {
        // Unknown jump to Block 0x4c54. Refer to 3-address code (TAC);
    }
    require(address(varg0), Error('UniswapV2Library: ZERO_ADDRESS'));
    return varg0, varg0;
}

function 0x4d79(uint256 varg0, uint256 varg1, uint256 varg2) private { 
    require(!bool(MEM[varg2] < 2), Error('UniswapV2Library: INVALID_PATH'));
    v0 = 0x7f8(MEM[varg2]);
    varg2 = v1 = MEM[64];
    0x7b7(v1, v0);
    v2 = 0x7f8(MEM[varg2]);
    CALLDATACOPY(v1 + 32, msg.data.length, v2 + ~31);
    require(MEM[varg2], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    MEM[v1 + 32] = varg1;
    v3 = v4 = 0;
    while (MEM[varg2] + ~0 <= MEM[varg2]) {
        if (v3 >= MEM[varg2] + ~0) {
            return varg2;
        } else {
            v3 = v5 = 19982;
            varg2 = v6 = 19964;
            v3 = v7 = 19947;
            v8 = 0x3cba(varg2, v3);
            v3 = v9 = address(MEM[v8]);
            v10 = v11 = 19940;
            v12 = v13 = 2685;
            v14 = v15 = 0x2373(v3);
            while (1) {
                v16 = 0x3cba(varg2, v14);
                varg2 = v17 = address(MEM[v16]);
                varg2 = v18 = 4;
                v3 = v19 = 20025;
                v20, v3 = 0x4c34(v3, v17);
                v3 = v21 = uint160.max;
                v3 = v22 = 0x4b93(v3, v3, v17);
                v23 = (v3 & v3).getReserves().gas(msg.gas);
                require(v23, MEM[64], RETURNDATASIZE());
                if (v23) {
                    v24 = v25 = 96;
                    if (v25 > RETURNDATASIZE()) {
                        v24 = RETURNDATASIZE();
                        0x7b7(MEM[64], v24);
                    } else {
                        0x7b7(MEM[64], v25);
                    }
                    require(MEM[64] + v24 - MEM[64] >= 96);
                    require(!0x902f1ac00000000000000000000000000000000000000000000000000000000);
                    require(!(MEM[MEM[64] + 32] - uint112(MEM[MEM[64] + 32])));
                    require(!(MEM[MEM[64] + 64] - uint32(MEM[MEM[64] + 64])));
                    v26 = uint112(0x902f1ac00000000000000000000000000000000000000000000000000000000);
                    v26 = v27 = uint112(MEM[MEM[64] + 32]);
                    if (0 != (v3 & v3 == v3 & v3)) {
                        // Unknown jump to Block 0x4deb. Refer to 3-address code (TAC);
                    }
                } else {
                    v26 = v28 = uint112(0);
                    v26 = v29 = uint112(0);
                    if (0 != (v3 & v3 == v3 & v3)) {
                        // Unknown jump to Block 0x4deb. Refer to 3-address code (TAC);
                    }
                }
                v30 = 0x3cba(varg2, v3);
                require(MEM[v30], Error('UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'));
                v31 = bool(v26);
                if (v31) {
                    v31 = v32 = bool(v26);
                    // Unknown jump to Block 0x4ef30x4d79. Refer to 3-address code (TAC);
                }
                require(v31, Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
                if (!MEM[v30] | (997 == MEM[v30] * 997 / MEM[v30])) {
                    require(!(MEM[v30] * 997 / 997 - MEM[v30]), Error('ds-math-mul-overflow'));
                    v33 = 0;
                    v34 = !v26;
                    if (bool(v26)) {
                        v33 = v35 = _SafeMul(MEM[v30] * 997, v26);
                        v36 = _SafeDiv(v35, v26);
                        v34 = v37 = v36 == MEM[v30] * 997;
                        // Unknown jump to Block 0x504d0x4d79. Refer to 3-address code (TAC);
                    }
                    require(v34, Error('ds-math-mul-overflow'));
                    if (!v26 | (1000 == v26 * 1000 / v26)) {
                        require(!(v26 * 1000 / 1000 - v26), Error('ds-math-mul-overflow'));
                        if (v26 * 1000 <= v26 * 1000 + MEM[v30] * 997) {
                            require(v26 * 1000 + MEM[v30] * 997 >= v26 * 1000, Error('ds-math-add-overflow'));
                            v10 = v38 = _SafeDiv(v33, v26 * 1000 + MEM[v30] * 997);
                            v12 = v39 = 19976;
                            v14 = v40 = 0x2373(v3);
                        }
                    }
                }
            }
            MEM[v16] = v10;
            if (v3 != ~0) {
                v3 += 1;
            }
        }
    }
    revert(Panic(17));
}

function 0x4fc6(uint256 varg0) private { 
    require(!varg0 | (997 == varg0 * 997 / varg0), Panic(17)); // arithmetic overflow or underflow
    require(!(varg0 * 997 / 997 - varg0), Error('ds-math-mul-overflow'));
    return varg0 * 997;
}

function 0x5115(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11) private { 
    v0 = 0x2381(v1);
    require(v0 < MEM[varg4], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    return (v0 << 5) + varg4 + 32, varg2, varg3, varg0, varg5, varg6, varg7, varg8, varg9, varg10, varg11;
}

function 0x51b4(uint256 varg0, uint256 varg1) private { 
    require(varg1, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    return varg0;
}

function 0x51dc(uint256 varg0) private { 
    require(!(address(msg.data[varg0]) - msg.data[varg0]));
    return msg.data[varg0];
}

function 0x5242(uint256 varg0, uint256 varg1, uint256 varg2) private { 
    require(!bool(MEM[varg2] < 2), Error('UniswapV2Library: INVALID_PATH'));
    v0 = 0x7f8(MEM[varg2]);
    v1 = v2 = MEM[64];
    0x7b7(v2, v0);
    v3 = 0x7f8(MEM[varg2]);
    CALLDATACOPY(v2 + 32, msg.data.length, v3 + ~31);
    if (MEM[varg2] + ~0 <= MEM[varg2]) {
        v4 = 0x3cba(v2, MEM[varg2] + ~0);
        MEM[v4] = varg1;
        v1 = v5 = MEM[varg2] + ~0;
        if (v5 <= MEM[varg2]) {
            while (!v1) {
                v1 = v6 = 21212;
                v1 = v7 = 21200;
                v1 = v8 = 21189;
                v9 = v10 = uint160.max;
                v11 = v12 = 21167;
                v13 = v14 = 0x23ec(v1);
                while (1) {
                    v15 = 0x3cba(v1, v13);
                    v1 = v16 = MEM[v15] & v9;
                    v17 = 0x3cba(v1, v1);
                    v1 = v18 = address(MEM[v17]);
                    v1 = v19 = 96;
                    v1 = v20 = 4;
                    v1 = v21 = 20025;
                    v22, v1 = v23 = 0x4c34(v16, v18);
                    v1 = v24 = uint160.max;
                    v1 = v25 = 0x4b93(v1, v16, v18);
                    v26 = (v1 & v1).getReserves().gas(msg.gas);
                    require(v26, MEM[64], RETURNDATASIZE());
                    if (v26) {
                        v27 = v28 = 96;
                        if (v28 > RETURNDATASIZE()) {
                            v27 = RETURNDATASIZE();
                            0x7b7(MEM[64], v27);
                        } else {
                            0x7b7(MEM[64], v28);
                        }
                        require(MEM[64] + v27 - MEM[64] >= 96);
                        require(!0x902f1ac00000000000000000000000000000000000000000000000000000000);
                        require(!(MEM[MEM[64] + 32] - uint112(MEM[MEM[64] + 32])));
                        require(!(MEM[MEM[64] + 64] - uint32(MEM[MEM[64] + 64])));
                        v29 = uint112(0x902f1ac00000000000000000000000000000000000000000000000000000000);
                        v29 = v30 = uint112(MEM[MEM[64] + 32]);
                        if (0 != (v1 & v1 == v1 & v1)) {
                            // Unknown jump to Block 0x52c5. Refer to 3-address code (TAC);
                        }
                    } else {
                        v29 = v31 = uint112(0);
                        v29 = v32 = uint112(0);
                        if (0 != (v1 & v1 == v1 & v1)) {
                            // Unknown jump to Block 0x52c5. Refer to 3-address code (TAC);
                        }
                    }
                    v33 = 0x3cba(v1, v1);
                    require(MEM[v33], Error('UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'));
                    if (v29) {
                        require(!bool(!v29), Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
                        // Unknown jump to Block 0x171a0x5242. Refer to 3-address code (TAC);
                    } else {
                        require(!bool(!v29), Error('UniswapV2Library: INSUFFICIENT_LIQUIDITY'));
                    }
                    v34 = 0;
                    v35 = !MEM[v33];
                    if (bool(MEM[v33])) {
                        v34 = v36 = _SafeMul(v29, MEM[v33]);
                        v37 = _SafeDiv(v36, MEM[v33]);
                        v35 = v38 = v37 == v29;
                        // Unknown jump to Block 0x504d0x5242. Refer to 3-address code (TAC);
                    }
                    require(v35, Error('ds-math-mul-overflow'));
                    if (!v34 | (1000 == v34 * 1000 / v34)) {
                        require(!(v34 * 1000 / 1000 - v34), Error('ds-math-mul-overflow'));
                        if (v29 - MEM[v33] <= v29) {
                            v39 = 0x4fc6(v29 - MEM[v33]);
                            v40 = _SafeDiv(v34 * 1000, v39);
                            v9 = v40 + 1;
                            if (v40 <= v9) {
                                require(v9 >= v40, Error('ds-math-add-overflow'));
                                v11 = v41 = 7028;
                                v13 = v42 = 0x23ec(v1);
                            }
                        }
                    }
                }
                MEM[v15] = v9;
                if (v1) {
                    v1 += ~0;
                    continue;
                }
            }
            return v1;
            v43, v44 = 0x4c34(v1, v1);
            MEM[MEM[64] + 32] = bytes20(v44 << 96);
            MEM[MEM[64] + 32 + 20] = bytes20(v43 << 96);
        }
    }
    revert(Panic(17));
}

function 0x527(uint256 varg0, uint256 varg1) private { 
    MEM[varg0] = 32;
    MEM[varg0 + 32] = MEM[varg1];
    v0 = v1 = varg0 + 64;
    v2 = v3 = varg1 + 32;
    v4 = v5 = 0;
    while (v4 >= MEM[varg1]) {
        MEM[v0] = MEM[v2];
        v0 += 32;
        v2 += 32;
        v4 += 1;
    }
    return v0;
}

function 0x548a(uint256 varg0, uint256 varg1) private { 
    v0 = 0x4053();
    v1 = varg0.call(MEM[(v0 + 32) len (MEM[v0])], MEM[0 len 0]).value(varg1).gas(msg.gas);
    v2 = 0x2810();
    require(v1, Error('TransferHelper: ETH_TRANSFER_FAILED'));
    return ;
}

function 0x5501(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { 
    require(!bool(block.timestamp > varg4), Error('UniswapV2Router: EXPIRED'));
    v0 = v1 = 21788;
    require(MEM[varg2], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    v2 = 32 + varg2;
    while (1) {
        v3 = v4 = address(MEM[v2]);
        // Unknown jump to Block {'0x6450x5501', '0x551c0x5501', '0x50a90x5501', '0x50990x5501'}. Refer to 3-address code (TAC);
        v5, v6 = 0x4c34(v3, v3);
        v7 = new bytes[](40);
        v7[20] = bytes20(v5 << 96);
        require(!((v7 + 96 > uint64.max) | (v7 + 96 < v7)), Panic(65)); // failed memory allocation (too much memory)
        v8 = v7.length;
        v9 = bytes20(v3 << 96);
        0x74b(MEM[64]);
        v3 = v10 = address(keccak256(0xff, v9, keccak256(bytes20(v6 << 96), bytes20(v5 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f));
        // Unknown jump to Block {'0x511f0x5501', '0x5bb0x5501'}. Refer to 3-address code (TAC);
        while (1) {
            v3 = address(v3);
            // Unknown jump to Block {'0x55b20x5501', '0x5bb0x5501', '0x51310x5501'}. Refer to 3-address code (TAC);
        }
        v11 = v12 = 20793;
        v11 = v13 = 0x4053();
        require(v3.code.size);
        v14 = MEM[64];
        MEM[v14] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000;
        v15 = 0x4069(v14 + 4, v3, v3, v3, v11);
        v16 = v3.call(MEM[v14 len (v15 - v14)], MEM[v14 len 0]).gas(msg.gas);
        if (v16) {
            v3 = v17 = 20862;
            if (v16) {
                v18 = v19 = 20880;
                0x733(v14);
            }
        }
        require(v3 != ~0, Panic(17)); // arithmetic overflow or underflow
        v3 += 1;
        v20 = 0x23ec(MEM[v3]);
        if (v3 >= v20) {
            require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            if (v3 > MEM[32 + v3]) {
                require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v21 = _SafeSub(v3, MEM[32 + v3]);
                0x548a(msg.sender, v21);
            } else {
                return v3;
            }
        } else {
            v0 = v22 = 20633;
            v2 = v23 = 0x3cba(v3, v3);
        }
        0x3e6(v14, v14);
        // Unknown jump to Block 0x51780x5501. Refer to 3-address code (TAC);
        // Unknown jump to Block 0x55970x5501. Refer to 3-address code (TAC);
        v3 = v24 = 21958;
        v3 = v25 = address(STORAGE[v26]);
        v27 = v28 = 18917;
        require(MEM[v29], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v30 = v31 = 32 + v29;
        while (1) {
            v3 = v32 = address(MEM[v30]);
            // Unknown jump to Block {'0x49e50x49d9B0x55b20x5501', '0x6450x49d9B0x55b20x5501'}. Refer to 3-address code (TAC);
            v27 = v33 = 1605;
            require(1 < MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v30 = 64 + v3;
            // Unknown jump to Block 0xa7d0x49d9B0x55b20x5501. Refer to 3-address code (TAC);
        }
        v34, v35 = 0x4c34(v3, v32);
        v36 = new bytes[](40);
        v36[20] = bytes20(v34 << 96);
        require(!((v36 + 96 > uint64.max) | (v36 + 96 < v36)), Panic(65)); // failed memory allocation (too much memory)
        v37 = v36.length;
        0x74b(MEM[64]);
        require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v38 = v3.transfer(address(keccak256(0xff, bytes20(v3 << 96), keccak256(bytes20(v35 << 96), bytes20(v34 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)), MEM[32 + v3]).value(v3).gas(msg.gas);
        if (v38) {
            v3 = v39 = 22003;
            if (v38) {
                v3 = v40 = 3252;
                v41 = v42 = 32;
                if (v42 > RETURNDATASIZE()) {
                    v41 = RETURNDATASIZE();
                    0x7b7(MEM[64], v41);
                } else {
                    0x7b7(MEM[64], v42);
                }
                require(MEM[64] + v41 - MEM[64] >= 32);
                require(!(bool(v43) - v43));
                // Unknown jump to Block 0x8820x5501. Refer to 3-address code (TAC);
            } else {
                require(v3, Panic(1)); // low-level assert failed
                v3 = v44 = 0;
            }
        }
        v3 = v45 = _factory;
        // Unknown jump to Block 0x4b930x5501. Refer to 3-address code (TAC);
        v0 = v46 = 20649;
        v47 = 0x2373(v3);
        v2 = v48 = 0x3cba(v3, v47);
        v49, v50 = 0x4c34(v3, v4);
        v51 = 0x2373(v3);
        v52 = 0x3cba(v3, v51);
        v3 = v53 = MEM[v52];
        if (address(v50) - address(v3)) {
            v3 = v54 = 20785;
            v3 = v55 = 1467;
            v3 = v56 = 1467;
            v3 = v57 = 0;
            // Unknown jump to Block 0x50e90x5501. Refer to 3-address code (TAC);
        } else {
            v3 = v58 = 20785;
            v3 = v59 = 1467;
            v3 = v60 = 1467;
            v3 = v61 = 0;
        }
        v62 = 0x23fa(MEM[v3]);
        if (v3 >= v62) {
            // Unknown jump to Block 0x51210x5501. Refer to 3-address code (TAC);
        } else {
            v2 = v63, v0 = v64, v3 = v65, v3 = v66, v3 = v67, v3 = v68, v3 = v69, v3 = v70, v3 = v71, v3, v3 = v72, v3 = v73 = 0x5115(_factory, 2685, 1605, v4, v3, 20767, v4, v3, v3, v3, v3, v3);
        }
        v3, v3, v74 = 0x4942(_wETH, uint160.max, v4, 21814, v3, v3);
        v3 = v75 = 0;
        v3 = 0x5242(_factory, v3, v3);
        require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v76 = MEM[32 + v3] > v3;
        require(!bool(v76), Error('UniswapV2Router: EXCESSIVE_INPUT_AMOUNT'));
        require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require(v74.code.size, v75, v75);
        v14 = v77 = MEM[64];
        v78 = v74.deposit().value(MEM[32 + v3]).gas(msg.gas);
        if (v78) {
            v3 = v79 = 21968;
            if (v78) {
                v18 = v80 = 22059;
                0x733(v77);
            }
        }
        v3 = v81 = 32;
        v3 = v82 = 21938;
        v3 = v83 = 1467;
        v3 = v84 = _wETH;
        // Unknown jump to Block 0x5bb0x5501. Refer to 3-address code (TAC);
    }
    RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());
    revert(MEM[64], RETURNDATASIZE());
    return v3;
}

function 0x5dfd(uint256 varg0, uint256 varg1) private { 
    if (varg0) {
        v0 = 0x4053();
        varg1 = v1 = block.coinbase.call(MEM[(v0 + 32) len (MEM[v0])], MEM[0 len 0]).value(varg0).gas(50000);
        v2 = 0x2810();
        if (varg1) {
            // Unknown jump to Block 0x4b780x5dfd. Refer to 3-address code (TAC);
        }
        require(varg1, Panic(1)); // low-level assert failed
    }
    if (bool(this.balance)) {
        v3 = 0;
        if (!this.balance) {
            v3 = v4 = 2300;
            // Unknown jump to Block 0x5e200x5dfd. Refer to 3-address code (TAC);
        }
        v5 = msg.sender.call().value(this.balance).gas(v3);
        require(v5, MEM[64], RETURNDATASIZE());
        return ;
    } else {
        return ;
    }
}

function 0x733(uint256 varg0) private { 
    require(varg0 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = varg0;
    return ;
}

function 0x74b(uint256 varg0) private { 
    require(!((varg0 + 128 > uint64.max) | (varg0 + 128 < varg0)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = varg0 + 128;
    return ;
}

function 0x766(uint256 varg0) private { 
    require(!((varg0 + 96 > uint64.max) | (varg0 + 96 < varg0)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = varg0 + 96;
    return ;
}

function 0x781(uint256 varg0) private { 
    require(!((varg0 + 32 > uint64.max) | (varg0 + 32 < varg0)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = varg0 + 32;
    return ;
}

function 0x79c(uint256 varg0) private { 
    require(!((varg0 + 64 > uint64.max) | (varg0 + 64 < varg0)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = varg0 + 64;
    return ;
}

function 0x7b7(uint256 varg0, uint256 varg1) private { 
    v0 = varg0 + (varg1 + 31 & ~0x1f);
    require(!((v0 > uint64.max) | (v0 < varg0)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = v0;
    return ;
}

function swapETHForExactTokens(uint256 varg0, address[] varg1, address varg2, uint256 varg3) public payable { 
    require(msg.data.length + ~3 >= 128);
    require(varg1 <= uint64.max);
    require(4 + varg1 + 31 < msg.data.length);
    v0 = v1 = varg1.data;
    v2 = 0x7f8(varg1.length);
    v3 = v4 = MEM[64];
    0x7b7(v4, v2);
    v5 = v6 = v4 + 32;
    require(v1 + (varg1.length << 5) <= msg.data.length);
    while (v0 >= v1 + (varg1.length << 5)) {
        require(!(address(msg.data[v0]) - msg.data[v0]));
        MEM[v5] = msg.data[v0];
        v5 = v5 + 32;
        v0 = v0 + 32;
    }
    require(!(varg2 - varg2));
    require(!bool(block.timestamp > varg3), Error('UniswapV2Router: EXPIRED'));
    v7 = v8 = 7980;
    require(varg1.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    v9 = v10 = 32 + v4;
    while (1) {
        v3 = v11 = address(MEM[v9]);
        // Unknown jump to Block {'0x1fe4', '0x50a90x7d3c', '0x6450x7d3c', '0x50990x7d3c', '0x1f2c'}. Refer to 3-address code (TAC);
        v12, v13 = 0x4c34(v3, v3);
        v14 = new bytes[](40);
        v14[20] = bytes20(v12 << 96);
        require(!((v14 + 96 > uint64.max) | (v14 + 96 < v14)), Panic(65)); // failed memory allocation (too much memory)
        v15 = v14.length;
        v16 = bytes20(v3 << 96);
        0x74b(MEM[64]);
        v3 = v17 = address(keccak256(0xff, v16, keccak256(bytes20(v13 << 96), bytes20(v12 << 96)), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f));
        // Unknown jump to Block {'0x5bb0x7d3c', '0x1ff0', '0x511f0x7d3c'}. Refer to 3-address code (TAC);
        require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v18 = v3.transfer(address(v17), MEM[32 + v3]).value(v3).gas(msg.gas);
        if (v18) {
            v3 = v19 = 1789;
            v3 = v20 = 8273;
            if (v18) {
                v21 = v22 = 32;
                if (v22 > RETURNDATASIZE()) {
                    v21 = RETURNDATASIZE();
                    0x7b7(MEM[64], v21);
                } else {
                    0x7b7(MEM[64], v22);
                }
                require(MEM[64] + v21 - MEM[64] >= 32);
                require(!(bool(v23) - v23));
            }
            require(v3, Panic(1)); // low-level assert failed
            v3 = v24 = 0;
        }
        while (1) {
            v3 = address(v3);
            // Unknown jump to Block {'0x5bb0x7d3c', '0x51310x7d3c', '0x1fc9'}. Refer to 3-address code (TAC);
        }
        v3 = v25 = 8176;
        v3 = v26 = address(STORAGE[v3]);
        v7 = v27 = 8164;
        require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v9 = v28 = 32 + v3;
        // Unknown jump to Block 0xa7d0x7d3c. Refer to 3-address code (TAC);
        v3 = v29 = 0x4053();
        require(v3.code.size);
        v3 = v30 = 0;
        v3 = v31 = 20836;
        v3 = v32 = MEM[64];
        MEM[v32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000;
        v33 = v32 + 4;
        v33 = v34 = 0x4069(v33, v3, v3, v3, v29);
        MEM[v33] = v3;
        MEM[v33 + 32] = v3;
        MEM[v33 + 64] = address(v3);
        MEM[v33 + 96] = 128;
        MEM[v33 + 128] = MEM[v3];
        v35 = v3.call(MEM[v3 len (v33 - v3)], MEM[v3 len v3]).value(v3).gas(msg.gas);
        if (v35) {
            v3 = v36 = 20862;
            if (v35) {
                v37 = v38 = 20880;
                0x733(v32);
            }
        }
        require(v3 != ~0, Panic(17)); // arithmetic overflow or underflow
        v3 += 1;
        v39 = 0x23ec(MEM[v3]);
        if (v3 >= v39) {
            require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            if (msg.value > MEM[32 + v3]) {
                require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v3 = v40 = _SafeSub(msg.value, MEM[32 + v3]);
                v3 = v41 = msg.sender;
                0x548a(v41, v40);
                v42 = MEM[64];
            } else {
                v42 = v43 = MEM[64];
            }
            MEM[v42] = 32;
            MEM[v42 + 32] = MEM[v3];
            v44 = v42 + 64;
            v45 = v3 + 32;
            v46 = 0;
            while (v46 >= MEM[v3]) {
                MEM[v44] = MEM[v45];
                v44 += 32;
                v45 += 32;
                v46 += 1;
            }
            return MEM[v42 len (v44 - v42)];
        } else {
            v7 = v47 = 20633;
            v9 = v48 = 0x3cba(v3, v3);
        }
        0x3e6(v3, v3);
        v3 = v49 = 32;
        v3 = v50 = 8137;
        v3 = v51 = 1467;
        v3 = v52 = _wETH;
        // Unknown jump to Block 0x5bb0x7d3c. Refer to 3-address code (TAC);
        // Unknown jump to Block 0x51780x7d3c. Refer to 3-address code (TAC);
        v3 = v53 = _factory;
        // Unknown jump to Block 0x4b930x7d3c. Refer to 3-address code (TAC);
        require(_wETH == address(v11), Error('UniswapV2Router: INVALID_PATH'));
        v3 = v54 = 0;
        v3 = 0x5242(_factory, v3, v3);
        require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require(!bool(msg.value < MEM[32 + v3]), Error('UniswapV2Router: EXCESSIVE_INPUT_AMOUNT'));
        require(MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require(_wETH.code.size, v54, v54);
        v3 = v55 = MEM[64];
        v56 = _wETH.deposit().value(MEM[32 + v3]).gas(msg.gas);
        if (v56) {
            v3 = v57 = 8239;
            if (v56) {
                v37 = v58 = 8371;
                0x733(v55);
            }
        }
        v7 = v59 = 1605;
        require(1 < MEM[v3], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v9 = 64 + v3;
        // Unknown jump to Block 0xa7d0x7d3c. Refer to 3-address code (TAC);
        v7 = v60 = 20649;
        v61 = 0x2373(v3);
        v9 = v62 = 0x3cba(v3, v61);
        v63, v64 = 0x4c34(v3, v11);
        v65 = 0x2373(v3);
        v66 = 0x3cba(v3, v65);
        v3 = v67 = MEM[v66];
        if (address(v64) - address(v3)) {
            v3 = v68 = 20785;
            v3 = v69 = 1467;
            v3 = v70 = 1467;
            v3 = v71 = 0;
            // Unknown jump to Block 0x50e90x7d3c. Refer to 3-address code (TAC);
        } else {
            v3 = v72 = 20785;
            v3 = v73 = 1467;
            v3 = v74 = 1467;
            v3 = v75 = 0;
        }
        v76 = 0x23fa(MEM[v3]);
        if (v3 >= v76) {
            // Unknown jump to Block 0x51210x7d3c. Refer to 3-address code (TAC);
        } else {
            v9 = v77, v7 = v78, v3 = v79, v3 = v80, v3 = v81, v3 = v82, v3 = v83, v3 = v84, v3 = v85, v3, v3 = v86, v3 = v87 = 0x5115(_factory, 2685, 1605, v11, v3, 20767, v11, v3, v3, v3, v3, v3);
        }
    }
    RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());
    revert(MEM[64], RETURNDATASIZE());
}

function 0x7f8(uint256 varg0) private { 
    require(varg0 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)
    return 32 + (varg0 << 5);
}

// Note: The function selector is not present in the original solidity code.
// However, we display it for the sake of completeness.

function __function_selector__(bytes4 function_selector) public payable { 
    MEM[64] = 128;
    if (msg.data.length >= 4) {
        v0 = function_selector >> 224;
        if (0x1ffc9a7 == v0) {
            supportsInterface(bytes4);
        } else if (0x54d50d4 == v0) {
            getAmountOut(uint256,uint256,uint256);
        } else if (0x88190f5 == v0) {
            0x088190f5();
        } else if (0x150b7a02 == v0) {
            onERC721Received(address,address,uint256,bytes);
        } else if (0x18cbafe5 == v0) {
            swapExactTokensForETH(uint256,uint256,address[],address,uint256);
        } else if (0x1f00ca74 == v0) {
            getAmountsIn(uint256,address[]);
        } else if (0x212d0645 == v0) {
            0x212d0645();
        } else if (0x24856bc3 == v0) {
            execute(bytes,bytes[]);
        } else if (0x2c5d3afd == v0) {
            0x2c5d3afd(v0);
        } else if (0x3593564c == v0) {
            execute(bytes,bytes[],uint256);
        } else if (0x387b6629 == v0) {
            SEAPORT();
        } else if (0x49df728c == v0) {
            withdrawTokens(address);
        } else if (0x4a25d94a == v0) {
            swapTokensForExactETH(uint256,uint256,address[],address,uint256);
        } else if (0x4aa4a4fc == v0) {
            WETH9();
        } else if (0x50431ce4 == v0) {
            withdrawNative();
        } else if (0x5757e6e5 == v0) {
            X2Y2();
        } else if (0x65df2e51 == v0) {
            FOUNDATION();
        } else if (0x6afdd850 == v0) {
            PERMIT2();
        } else if (0x709a1cc2 == v0) {
            collectRewards(bytes);
        } else if (0x715018a6 == v0) {
            renounceOwnership();
        } else if (0x791ac947 == v0) {
            swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256);
        } else if (0x795e6e59 == v0) {
            CRYPTOPUNKS();
        } else if (0x79818a58 == v0) {
            0x79818a58();
        } else if (0x8580114a == v0) {
            0x8580114a();
        } else if (0x85f8c259 == v0) {
            getAmountIn(uint256,uint256,uint256);
        } else if (0x8da5cb5b == v0) {
            owner();
        } else if (0x9239127f == v0) {
            0x9239127f();
        } else if (0x99d8fae3 == v0) {
            UNISWAP_V2_FACTORY();
        } else if (0xa0136443 == v0) {
            0xa0136443();
        } else if (0xa5be382e == v0) {
            swapExactETHForTokens(uint256,uint256,address[],address,uint256);
        } else if (0xaad8a491 == v0) {
            0xaad8a491();
        } else if (0xad5c4648 == v0) {
            WETH();
        } else if (0xad615dec == v0) {
            quote(uint256,uint256,uint256);
        } else if (0xb38248c7 == v0) {
            0xb38248c7();
        } else if (0xb6f9de95 == v0) {
            swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256);
        } else if (0xbb8da0f3 == v0) {
            LOOKS_RARE();
        } else if (0xbc197c81 == v0) {
            onERC1155BatchReceived(address,address,uint256[],uint256[],bytes);
        } else if (0xc45a0155 == v0) {
            factory();
        } else if (0xc62029ed == v0) {
            0xc62029ed();
        } else if (0xcc988feb == v0) {
            0xcc988feb();
        } else if (0xd06ca61f == v0) {
            getAmountsOut(uint256,address[]);
        } else if (0xe81dc5c1 == v0) {
            0xe81dc5c1();
        } else if (0xeb92db27 == v0) {
            initialize(uint64);
        } else if (0xf23a6e61 == v0) {
            onERC1155Received(address,address,uint256,uint256,bytes);
        } else if (0xf2fde38b == v0) {
            transferOwnership(address);
        } else if (0xf5da6959 == v0) {
            SUDOSWAP();
        } else if (0xf73e5aab == v0) {
            UNISWAP_V3_FACTORY();
        } else if (0xf9da581d == v0) {
            0xf9da581d();
        } else if (0xfa461e33 == v0) {
            uniswapV3SwapCallback(int256,int256,bytes);
        } else if (!(0xfb3bdb41 - v0)) {
            swapETHForExactTokens(uint256,address[],address,uint256);
        }
    }
    require(!msg.data.length);
}
